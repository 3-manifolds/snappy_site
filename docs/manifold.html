

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manifold: the main class &mdash; SnapPy 3.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/snappy_sphinx_rtd_theme.css?v=1b8ec2a8" />

  
    <link rel="shortcut icon" href="_static/SnapPy.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=828ea960"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ManifoldHP: High-precision variant" href="manifoldhp.html" />
    <link rel="prev" title="The snappy module and its classes" href="snappy.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            SnapPy
              <img src="_static/SnapPy-horizontal-128.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installing.html">Installing SnapPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="screenshots.html">Screenshots: SnapPy in action</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="snappy.html">The snappy module and its classes</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Manifold: the main class</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#snappy.Manifold"><code class="docutils literal notranslate"><span class="pre">Manifold</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.DT_code"><code class="docutils literal notranslate"><span class="pre">Manifold.DT_code()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.alexander_polynomial"><code class="docutils literal notranslate"><span class="pre">Manifold.alexander_polynomial()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.browse"><code class="docutils literal notranslate"><span class="pre">Manifold.browse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.canonical_retriangulation"><code class="docutils literal notranslate"><span class="pre">Manifold.canonical_retriangulation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.canonize"><code class="docutils literal notranslate"><span class="pre">Manifold.canonize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.chern_simons"><code class="docutils literal notranslate"><span class="pre">Manifold.chern_simons()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.complex_volume"><code class="docutils literal notranslate"><span class="pre">Manifold.complex_volume()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.copy"><code class="docutils literal notranslate"><span class="pre">Manifold.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.cover"><code class="docutils literal notranslate"><span class="pre">Manifold.cover()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.cover_info"><code class="docutils literal notranslate"><span class="pre">Manifold.cover_info()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.covers"><code class="docutils literal notranslate"><span class="pre">Manifold.covers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.cusp_area_matrix"><code class="docutils literal notranslate"><span class="pre">Manifold.cusp_area_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.cusp_areas"><code class="docutils literal notranslate"><span class="pre">Manifold.cusp_areas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.cusp_info"><code class="docutils literal notranslate"><span class="pre">Manifold.cusp_info()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.cusp_neighborhood"><code class="docutils literal notranslate"><span class="pre">Manifold.cusp_neighborhood()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.cusp_translations"><code class="docutils literal notranslate"><span class="pre">Manifold.cusp_translations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.dehn_fill"><code class="docutils literal notranslate"><span class="pre">Manifold.dehn_fill()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.dirichlet_domain"><code class="docutils literal notranslate"><span class="pre">Manifold.dirichlet_domain()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.drill"><code class="docutils literal notranslate"><span class="pre">Manifold.drill()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.drill_word"><code class="docutils literal notranslate"><span class="pre">Manifold.drill_word()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.drill_words"><code class="docutils literal notranslate"><span class="pre">Manifold.drill_words()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.dual_curves"><code class="docutils literal notranslate"><span class="pre">Manifold.dual_curves()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.edge_valences"><code class="docutils literal notranslate"><span class="pre">Manifold.edge_valences()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.exterior_to_link"><code class="docutils literal notranslate"><span class="pre">Manifold.exterior_to_link()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.filled_triangulation"><code class="docutils literal notranslate"><span class="pre">Manifold.filled_triangulation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.fundamental_group"><code class="docutils literal notranslate"><span class="pre">Manifold.fundamental_group()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.gluing_equations"><code class="docutils literal notranslate"><span class="pre">Manifold.gluing_equations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.gluing_equations_pgl"><code class="docutils literal notranslate"><span class="pre">Manifold.gluing_equations_pgl()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.has_finite_vertices"><code class="docutils literal notranslate"><span class="pre">Manifold.has_finite_vertices()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.high_precision"><code class="docutils literal notranslate"><span class="pre">Manifold.high_precision()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.holonomy_matrix_entries"><code class="docutils literal notranslate"><span class="pre">Manifold.holonomy_matrix_entries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.homological_longitude"><code class="docutils literal notranslate"><span class="pre">Manifold.homological_longitude()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.homology"><code class="docutils literal notranslate"><span class="pre">Manifold.homology()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.hyperbolic_SLN_torsion"><code class="docutils literal notranslate"><span class="pre">Manifold.hyperbolic_SLN_torsion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.hyperbolic_adjoint_torsion"><code class="docutils literal notranslate"><span class="pre">Manifold.hyperbolic_adjoint_torsion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.hyperbolic_torsion"><code class="docutils literal notranslate"><span class="pre">Manifold.hyperbolic_torsion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.identify"><code class="docutils literal notranslate"><span class="pre">Manifold.identify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.inside_view"><code class="docutils literal notranslate"><span class="pre">Manifold.inside_view()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.invariant_trace_field_gens"><code class="docutils literal notranslate"><span class="pre">Manifold.invariant_trace_field_gens()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.is_isometric_to"><code class="docutils literal notranslate"><span class="pre">Manifold.is_isometric_to()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.is_orientable"><code class="docutils literal notranslate"><span class="pre">Manifold.is_orientable()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.is_two_bridge"><code class="docutils literal notranslate"><span class="pre">Manifold.is_two_bridge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.isometry_signature"><code class="docutils literal notranslate"><span class="pre">Manifold.isometry_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.isomorphisms_to"><code class="docutils literal notranslate"><span class="pre">Manifold.isomorphisms_to()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.length_spectrum"><code class="docutils literal notranslate"><span class="pre">Manifold.length_spectrum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.length_spectrum_alt"><code class="docutils literal notranslate"><span class="pre">Manifold.length_spectrum_alt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.length_spectrum_alt_gen"><code class="docutils literal notranslate"><span class="pre">Manifold.length_spectrum_alt_gen()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.link"><code class="docutils literal notranslate"><span class="pre">Manifold.link()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.name"><code class="docutils literal notranslate"><span class="pre">Manifold.name()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.normal_boundary_slopes"><code class="docutils literal notranslate"><span class="pre">Manifold.normal_boundary_slopes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.normal_surfaces"><code class="docutils literal notranslate"><span class="pre">Manifold.normal_surfaces()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.num_cusps"><code class="docutils literal notranslate"><span class="pre">Manifold.num_cusps()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.num_tetrahedra"><code class="docutils literal notranslate"><span class="pre">Manifold.num_tetrahedra()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.orientation_cover"><code class="docutils literal notranslate"><span class="pre">Manifold.orientation_cover()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.plink"><code class="docutils literal notranslate"><span class="pre">Manifold.plink()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.polished_holonomy"><code class="docutils literal notranslate"><span class="pre">Manifold.polished_holonomy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.ptolemy_generalized_obstruction_classes"><code class="docutils literal notranslate"><span class="pre">Manifold.ptolemy_generalized_obstruction_classes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.ptolemy_obstruction_classes"><code class="docutils literal notranslate"><span class="pre">Manifold.ptolemy_obstruction_classes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.ptolemy_variety"><code class="docutils literal notranslate"><span class="pre">Manifold.ptolemy_variety()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.randomize"><code class="docutils literal notranslate"><span class="pre">Manifold.randomize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.reverse_orientation"><code class="docutils literal notranslate"><span class="pre">Manifold.reverse_orientation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.save"><code class="docutils literal notranslate"><span class="pre">Manifold.save()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.set_name"><code class="docutils literal notranslate"><span class="pre">Manifold.set_name()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.set_peripheral_curves"><code class="docutils literal notranslate"><span class="pre">Manifold.set_peripheral_curves()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.set_target_holonomy"><code class="docutils literal notranslate"><span class="pre">Manifold.set_target_holonomy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.set_tetrahedra_shapes"><code class="docutils literal notranslate"><span class="pre">Manifold.set_tetrahedra_shapes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.short_slopes"><code class="docutils literal notranslate"><span class="pre">Manifold.short_slopes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.simplify"><code class="docutils literal notranslate"><span class="pre">Manifold.simplify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.slice_obstruction_HKL"><code class="docutils literal notranslate"><span class="pre">Manifold.slice_obstruction_HKL()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.solution_type"><code class="docutils literal notranslate"><span class="pre">Manifold.solution_type()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.split"><code class="docutils literal notranslate"><span class="pre">Manifold.split()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.splitting_surfaces"><code class="docutils literal notranslate"><span class="pre">Manifold.splitting_surfaces()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.symmetric_triangulation"><code class="docutils literal notranslate"><span class="pre">Manifold.symmetric_triangulation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.symmetry_group"><code class="docutils literal notranslate"><span class="pre">Manifold.symmetry_group()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.symplectic_basis"><code class="docutils literal notranslate"><span class="pre">Manifold.symplectic_basis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.tetrahedra_field_gens"><code class="docutils literal notranslate"><span class="pre">Manifold.tetrahedra_field_gens()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.tetrahedra_shapes"><code class="docutils literal notranslate"><span class="pre">Manifold.tetrahedra_shapes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.trace_field_gens"><code class="docutils literal notranslate"><span class="pre">Manifold.trace_field_gens()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.triangulation_isosig"><code class="docutils literal notranslate"><span class="pre">Manifold.triangulation_isosig()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.use_field_conversion"><code class="docutils literal notranslate"><span class="pre">Manifold.use_field_conversion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.verify_hyperbolicity"><code class="docutils literal notranslate"><span class="pre">Manifold.verify_hyperbolicity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.volume"><code class="docutils literal notranslate"><span class="pre">Manifold.volume()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.with_hyperbolic_structure"><code class="docutils literal notranslate"><span class="pre">Manifold.with_hyperbolic_structure()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappy.Manifold.without_hyperbolic_structure"><code class="docutils literal notranslate"><span class="pre">Manifold.without_hyperbolic_structure()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manifoldhp.html">ManifoldHP: High-precision variant</a></li>
<li class="toctree-l2"><a class="reference internal" href="triangulation.html">Triangulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="additional_classes.html">Additional Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="censuses.html">Census manifolds</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="plink.html">Using SnapPy’s link editor</a></li>
<li class="toctree-l1"><a class="reference internal" href="spherogram.html">Links: planar diagrams and invariants</a></li>
<li class="toctree-l1"><a class="reference internal" href="snap.html">Number theory of hyperbolic 3-manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="verify.html">Verified computations</a></li>
<li class="toctree-l1"><a class="reference internal" href="other.html">Other components</a></li>
<li class="toctree-l1"><a class="reference internal" href="news.html">News</a></li>
<li class="toctree-l1"><a class="reference internal" href="credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">Reporting bugs and other problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">To Do List</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development Basics</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SnapPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="snappy.html">The snappy module and its classes</a></li>
      <li class="breadcrumb-item active">Manifold: the main class</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="manifold-the-main-class">
<h1>Manifold: the main class<a class="headerlink" href="#manifold-the-main-class" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="snappy.Manifold">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">snappy.</span></span><span class="sig-name descname"><span class="pre">Manifold</span></span><a class="headerlink" href="#snappy.Manifold" title="Link to this definition"></a></dt>
<dd><p>A Manifold is a <a class="reference internal" href="triangulation.html#snappy.Triangulation" title="snappy.Triangulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Triangulation</span></code></a> together with a geometric structure.
That is, a Manifold is an ideal triangulation of the interior of a
compact 3-manifold with torus and Klein-bottle boundary components, where
each tetrahedron has been assigned the geometry of an ideal tetrahedron
in hyperbolic 3-space. A Dehn-filling can be specified for each
boundary component, allowing the description of closed 3-manifolds,
some orbifolds and cone 3-manifolds. Here’s a quick example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;9_42&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>  
<span class="go">4.05686022</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> 
<span class="go">[-4.278936315 + 1.95728679*I]</span>
</pre></div>
</div>
<p>This is an example for running SnapPy inside Sage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">snappy</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">snappy</span><span class="o">.</span><span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125(1,2)(4,5)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">()</span>
<span class="kc">True</span>
</pre></div>
</div>
<p>An alternative way of running SnapPy inside Sage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">snappy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m123&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">()</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>A Manifold can be specified in a number of ways, e.g.</p>
<ul class="simple">
<li><p>Manifold(‘9_42’) : The complement of the knot 9_42 in S^3.</p></li>
<li><p>Manifold(‘m125(1,2)(4,5)’) : The SnapPea census manifold m125
where the first cusp has Dehn filling (1,2) and the second cusp has
filling (4,5).</p></li>
<li><p>Manifold() : Opens a link editor window where can you
specify a link complement.</p></li>
</ul>
<p>In general, the specification can be from among the below, with
information on Dehn fillings added.</p>
<ul>
<li><p>SnapPea cusped census manifolds: e.g. ‘m123’, ‘s123’, ‘v123’.</p></li>
<li><p>Link complements:</p>
<blockquote>
<div><ul class="simple">
<li><p>Rolfsen’s table: e.g. ‘4_1’, ‘04_1’, ‘5^2_6’, ‘6_4^7’, ‘L20935’, ‘l104001’.</p></li>
<li><p>Hoste-Thistlethwaite Knotscape table:  e.g. ‘11a17’ or ‘12n345’</p></li>
<li><p>Callahan-Dean-Weeks-Champanerkar-Kofman-Patterson knots: e.g. ‘K6_21’.</p></li>
<li><p>Dowker-Thistlethwaite code: e.g. ‘DT:[(6,8,2,4)]’</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Once-punctured torus bundles: e.g. ‘b++LLR’, ‘b+-llR’, ‘bo-RRL’, ‘bn+LRLR’</p></li>
<li><p>Fibered manifold associated to a braid: ‘Braid[1,2,-3,4]’</p>
<p>Here, the braid is thought of as a mapping class of the
punctured disc, and this manifold is the corresponding
mapping torus.  If you want the braid closure, do (1,0) filling
of the last cusp.</p>
</li>
<li><p>From mapping class group data using Twister:</p>
<p>‘Bundle(S_{1,1}, [a0, B1])’ or ‘Splitting(S_{1,0}, [b1, A0], [a0,B1])’</p>
<p>See the help for the ‘twister’ module for more.</p>
</li>
<li><p>A SnapPea triangulation or link projection file: ‘filename’</p>
<p>The file will be loaded if found in the current directory or the
path given by the shell variable <code class="docutils literal notranslate"><span class="pre">SNAPPEA_MANIFOLD_DIRECTORY</span></code>.
See <a class="reference internal" href="#snappy.Manifold.save" title="snappy.Manifold.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Manifold.save()</span></code></a> for details.</p>
</li>
<li><p>A string containing the contents of a SnapPea triangulation or link
projection file.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.DT_code">
<span class="sig-name descname"><span class="pre">DT_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flips</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.DT_code" title="Link to this definition"></a></dt>
<dd><p>Return the Dowker-Thistlethwaite code of this link complement,
if it is a link complement. The DT code is intended to be an
immutable attribute, for use with knot and link exteriors
only, which is set only when the manifold was created.</p>
<p>Here is the Whitehead link:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L5a1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">()</span>
<span class="go">[(6, 8), (2, 10, 4)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;ebbccdaeb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flips</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;ebbccdaeb.01110&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">flips</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([(6, 8), (2, 10, 4)], [0, 1, 1, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.alexander_polynomial">
<span class="sig-name descname"><span class="pre">alexander_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.alexander_polynomial" title="Link to this definition"></a></dt>
<dd><p>Computes the multivariable Alexander polynomial of the manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K12n123&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">()</span>
<span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">14</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">34</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">45</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">34</span><span class="o">*</span><span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">14</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span>

<span class="n">sage</span><span class="p">:</span> <span class="n">N</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;v1539(5,1)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">()</span>
<span class="n">a</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>Any provided keyword arguments are passed to
<a class="reference internal" href="triangulation.html#snappy.Triangulation.fundamental_group" title="snappy.Triangulation.fundamental_group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fundamental_group</span></code></a> and
so affect the group presentation used in the computation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.browse">
<span class="sig-name descname"><span class="pre">browse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.browse" title="Link to this definition"></a></dt>
<dd><p>Opens browser window with a graphical interface, which allows to
explore the manifold and interact with it.
This includes: invariants, Dirichlet domain, cusp neighborhoods,
inside view, symmetry, Dehn filling, drilling, etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">browse</span><span class="p">()</span>  
</pre></div>
</div>
<p>This does not work when using SnapPy in a Docker container.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.canonical_retriangulation">
<span class="sig-name descname"><span class="pre">canonical_retriangulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval_bits_precs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[53,</span> <span class="pre">212]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_bits_prec_and_degrees</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[(212,</span> <span class="pre">10),</span> <span class="pre">(1000,</span> <span class="pre">20),</span> <span class="pre">(2000,</span> <span class="pre">20)]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="triangulation.html#snappy.Triangulation" title="snappy.Triangulation"><span class="pre">Triangulation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><span class="pre">Manifold</span></a></span></span><a class="headerlink" href="#snappy.Manifold.canonical_retriangulation" title="Link to this definition"></a></dt>
<dd><p>Returns a triangulation canonically associated to the hyperbolic manifold.
That is, the triangulation is (up to combinatorial isomorphism relabeling
the tetrahedra and vertices) completely determined by the isometry type of
the hyperbolic manifold.</p>
<p>Manifolds with incomplete cusps are rejected (unlike in the case of
<a class="reference internal" href="#snappy.Manifold.isometry_signature" title="snappy.Manifold.isometry_signature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isometry_signature</span></code></a>).</p>
<p>We now describe the canonical retriangulation. If all cells of
the canonical cell decomposition (defined by <a class="reference external" href="https://projecteuclid.org/euclid.jdg/1214441650">Epstein and Penner ‘88</a>) are tetrahedral,
<a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation</span></code></a>
simply returns that ideal triangulation as a
<a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manifold</span></code></a>. Here is an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m015&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;all tetrahedra positively oriented&#39;</span>
</pre></div>
</div>
<p>If there are non-tetrahedral cells,
<a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation</span></code></a>
subdivides the canonical cell decomposition. It introduces a finite vertex
for each canonical cell resulting in a
<a class="reference internal" href="triangulation.html#snappy.Triangulation" title="snappy.Triangulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Triangulation</span></code></a>. Here is an example where the
canonical cell is a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m412&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The canonical retriangulation can be used to find the symmetries of a
single manifold. It also can compute the isometries between two
manifolds. We do this using
<a class="reference internal" href="triangulation.html#snappy.Triangulation.isomorphisms_to" title="snappy.Triangulation.isomorphisms_to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isomorphisms_to</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;5_2&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m015&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> 
<span class="go">[0 -&gt; 0</span>
<span class="go">[1 0]</span>
<span class="go">[0 1]</span>
<span class="go">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> 
<span class="go">[0 -&gt; 0</span>
<span class="go">[-1  2]</span>
<span class="go">[ 0 -1]</span>
<span class="go">...</span>
</pre></div>
</div>
<p>The canonical retriangulation is also the basis for the
<a class="reference internal" href="#snappy.Manifold.isometry_signature" title="snappy.Manifold.isometry_signature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isometry_signature</span></code></a>.</p>
<p><strong>Subdivision</strong></p>
<p>If the canonical cell decomposition has a non-tetrahedral cell, the method
subdivides. You can think of the subdivision in either of the following
(equivalent) ways:</p>
<ul class="simple">
<li><p>A coarsening of the barycentric subdivision with only a quarter of the
number of tetrahedra. That is, take the barycentric subdivision and
merge the four tetrahedra adjacent to a barycentric edge connecting
an edge midpoint to a face midpoint.</p></li>
<li><p>Taking the double suspension of each face (which is an ideal n-gon)
about the centers of the two neighboring 3-cells. Then split each
such topological “lens” into n tetrahedra along its central axis.</p></li>
</ul>
<p><strong>Verified computations</strong></p>
<p>While the canonical retriangulation is combinatorial, some intermediate
computations are numerical. Thus, if <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">False</span></code>,
floating-point issues can arise.
(Arguably this gave rise to a mistake in the
non-orientable census. <code class="docutils literal notranslate"><span class="pre">x101</span></code> and <code class="docutils literal notranslate"><span class="pre">x103</span></code> were later identified as
the same by <a class="reference external" href="http://arxiv.org/abs/1311.7615">Burton ‘14</a>.)</p>
<p>The method can be made <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified</span></a> by passing
<code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;v2986&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">(</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span> <span class="c1"># Cell decomposition verified to be tetrahedral</span>
<span class="kc">False</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># Verified isometry signature.</span>
<span class="s1">&#39;jvLALQQdeefgihihiokcmmwwswg&#39;</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="c1"># Verified to have no (non-trivial) symmetries.</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Interval arithmetic can only be used to verify the canonical cell decomposition
if all cells are tetrahedral. For non-tetrahedral cells, the method
automatically switches to
exact methods to verify the canonical cell decomposition. That is, it uses
snap-like methods
(<a class="reference external" href="http://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm">LLL-algorithm</a>)
to guess a representation of the
shapes in the shape field. It then uses exact arithmetic to verify the
shapes form a valid geometric structure and compute the necessary tilts
to verify the canonical cell decomposition. Note that this can take a
long time!</p>
<p>Here is an example where exact methods are used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m412&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">(</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span> <span class="c1"># Has non-tetrahedral cell</span>
<span class="kc">True</span>
</pre></div>
</div>
<p>If the canonical retriangulation cannot be verified, an exception will be
raised. (Note that this is new (and safer) in Version 3.2. Prior to that
version, <a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Manifold.canonical_retriangulation()</span></code></a> could return <code class="docutils literal notranslate"><span class="pre">None</span></code>
instead.)</p>
<p>Here is an example where we skip the (potentially lengthy) exact methods
needed to verify a non-tetrahedral cell. The method fails (early
and with an exception) since the cells are actually tetrahedral:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m412&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">(</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">exact_bits_prec_and_degrees</span> <span class="o">=</span> <span class="p">[])</span> <span class="c1"># doctest: +ELLIPSIS +IGNORE_EXCEPTION_DETAIL</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="o">...</span>
<span class="n">snappy</span><span class="o">.</span><span class="n">verify</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">TiltInequalityNumericalVerifyError</span><span class="p">:</span> <span class="n">Numerical</span> <span class="n">verification</span> <span class="n">that</span> <span class="n">tilt</span> <span class="ow">is</span> <span class="n">negative</span> <span class="n">has</span> <span class="n">failed</span><span class="p">:</span> <span class="o">...</span> <span class="o">&lt;</span> <span class="mi">0</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verified</strong> – Use <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computation</span></a>.</p></li>
<li><p><strong>interval_bits_precs</strong> – Only relevant if <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>.
A list of (increasing) precisions used to try to
certify the canonical cell decomposition using intervals. Each
precision is tried until we succeed. If none succeeded, we move on
to exact methods.</p></li>
<li><p><strong>exact_bits_prec_and_degrees</strong> – Only relevant if <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>.
A list of pairs (precision, max degree) used when the
LLL-algorithm is trying to find the defining
polynomial of the shape field with
<code class="docutils literal notranslate"><span class="pre">ListOfApproximateAlgebraicNumbers.find_field</span></code>.
Each pair is tried until we succeed.</p></li>
<li><p><strong>verbose</strong> – Print information about the methods tried to compute and verify the
canonical retriangulation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the canonical cell decomposition exists entirely of
(hyperbolic ideal) tetrahedra, a <a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manifold</span></code></a> with those
tetrahedra.
Otherwise, a <a class="reference internal" href="triangulation.html#snappy.Triangulation" title="snappy.Triangulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Triangulation</span></code></a> that is a subdivision of the
canonical cell decomposition.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.canonize">
<span class="sig-name descname"><span class="pre">canonize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#snappy.Manifold.canonize" title="Link to this definition"></a></dt>
<dd><p>Change the triangulation to an arbitrary retriangulation of
the canonical cell decomposition. See
<a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation</span></code></a>
to get the actual canonical cell decomposition.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m007&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">canonize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Note: Due to rounding error, it is possible that this is actually
not a retriangulation of the canonical cell decomposition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.chern_simons">
<span class="sig-name descname"><span class="pre">chern_simons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">accuracy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.chern_simons" title="Link to this definition"></a></dt>
<dd><p>Returns the Chern-Simons invariant of the manifold (normalized by
dividing it by <span class="math notranslate nohighlight">\(2 \pi^2\)</span>), if it is known.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span> 
<span class="go">-0.15320413</span>
</pre></div>
</div>
<p>The return value has an extra attribute, accuracy, which
is the number of digits of accuracy as <em>estimated</em> by SnapPea.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">(</span><span class="n">accuracy</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">56</span><span class="p">)</span> <span class="c1"># Low and High precision</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By default, when the manifold has at least one cusp, Zickert’s
algorithm is used; when the manifold is closed we use SnapPea’s
original algorithm, which is based on Meyerhoff-Hodgson-Neumann.</p>
<p>Note: When computing the Chern-Simons invariant of a closed
manifold, one must sometimes compute it first for the unfilled
manifold so as to initialize SnapPea’s internals.  For instance,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span> 
<span class="go">-0.15320413</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span> 
<span class="go">0.07731787</span>
</pre></div>
</div>
<p>works, but will fail with
<code class="docutils literal notranslate"><span class="pre">ValueError:</span> <span class="pre">The</span> <span class="pre">Chern-Simons</span> <span class="pre">invariant</span> <span class="pre">isn't</span> <span class="pre">currently</span> <span class="pre">known.</span></code>
if the first call to chern_simons is not made.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.complex_volume">
<span class="sig-name descname"><span class="pre">complex_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verified_modulo_2_torsion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.complex_volume" title="Link to this definition"></a></dt>
<dd><p>Returns the complex volume modulo <span class="math notranslate nohighlight">\(i \pi^2\)</span> which is given by</p>
<div class="math notranslate nohighlight">
\[\text{vol} + i \text{CS}\]</div>
<p>where <span class="math notranslate nohighlight">\(\text{CS}\)</span> is the (unnormalized) Chern-Simons invariant.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">complex_volume</span><span class="p">()</span> 
<span class="go">2.82812209 - 3.02412838*I</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#snappy.Manifold.chern_simons" title="snappy.Manifold.chern_simons"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chern_simons</span></code></a>
normalizes the Chern-Simons invariant by dividing it by
<span class="math notranslate nohighlight">\(2 \pi^2 = 19.7392...\)</span></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span> 
<span class="go">-0.153204133297152</span>
</pre></div>
</div>
<p>More examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">complex_volume</span><span class="p">()</span> 
<span class="go">2.22671790 + 1.52619361*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;3_1&quot;</span><span class="p">)</span> <span class="c1"># A non-hyperbolic example.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvol</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">complex_volume</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvol</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> 
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvol</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span> 
<span class="go">-1.64493407</span>
</pre></div>
</div>
<p>If no cusp is filled or there is only one cusped (filled or
unfilled), the complex volume can be verified up to multiples
of <span class="math notranslate nohighlight">\(i \pi^2 /2\)</span> by passing <code class="docutils literal notranslate"><span class="pre">verified_modulo_2_torsion</span> <span class="pre">=</span> <span class="pre">True</span></code>
when inside SageMath. Higher precision can be requested
with <code class="docutils literal notranslate"><span class="pre">bits_prec</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&quot;m015&quot;)
sage: M.complex_volume(verified_modulo_2_torsion=True, bits_prec = 93) # doctest: +NUMERIC21
2.828122088330783162764? + 1.910673824035377649698?*I
sage: M = Manifold(&quot;m015(3,4)&quot;)
sage: M.complex_volume(verified_modulo_2_torsion=True) # doctest: +NUMERIC6
2.625051576? - 0.537092383?*I
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.copy" title="Link to this definition"></a></dt>
<dd><p>Returns a copy of the manifold</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cover">
<span class="sig-name descname"><span class="pre">cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">permutation_rep</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><span class="pre">snappy.Manifold</span></a></span></span><a class="headerlink" href="#snappy.Manifold.cover" title="Link to this definition"></a></dt>
<dd><p>Returns a <a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manifold</span></code></a> representing the finite cover specified by a
transitive permutation representation.  The representation is
specified by a list of permutations, one for each generator of the
simplified presentation of the fundamental group.  Each permutation is
specified as a list <code class="docutils literal notranslate"><span class="pre">P</span></code> such such that <code class="docutils literal notranslate"><span class="pre">set(P)</span> <span class="pre">==</span> <span class="pre">set(range(d))</span></code>
where <code class="docutils literal notranslate"><span class="pre">d</span></code> is the degree of the cover.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N0</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">N0</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0000000001</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If within SageMath, the permutations can also be of type
<code class="docutils literal notranslate"><span class="pre">PermutationGroupElement</span></code>, in which case they act on the set
<code class="docutils literal notranslate"><span class="pre">range(1,</span> <span class="pre">d</span> <span class="pre">+</span> <span class="pre">1)</span></code>.  Or, you can specify a GAP or Magma subgroup
of the fundamental group.     Some examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The basic method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">N0</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</pre></div>
</div>
<p>From a Gap subgroup:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">gap</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">())</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">LowIndexSubgroupsFpGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">)[</span><span class="mi">9</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N1</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N0</span> <span class="o">==</span> <span class="n">N1</span>
<span class="kc">True</span>
</pre></div>
</div>
<p>Or a homomorphism to a permutation group:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">f</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">GQuotients</span><span class="p">(</span><span class="n">PSL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N2</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N2</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="c1"># doctest: +NUMERIC9</span>
<span class="mf">8.00000000</span>
</pre></div>
</div>
<p>Or maybe we want larger cover coming from the kernel of this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">N3</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">Kernel</span><span class="p">())</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N3</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="c1"># doctest: +NUMERIC9</span>
<span class="mf">168.00000000</span>
</pre></div>
</div>
<p>Check the homology against what Gap computes directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">N3</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span><span class="o">.</span><span class="n">betti_number</span><span class="p">()</span>
<span class="mi">32</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">len</span><span class="p">([</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">Kernel</span><span class="p">()</span><span class="o">.</span><span class="n">AbelianInvariants</span><span class="p">()</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
<span class="mi">32</span>
</pre></div>
</div>
<p>We can do the same for Magma:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">magma</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">())</span>             <span class="c1">#doctest: +SKIP</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Q</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">pQuotient</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nvals</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>          <span class="c1">#doctest: +SKIP</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">Kernel</span><span class="p">())</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>                 <span class="c1">#doctest: +SKIP</span>
<span class="mf">10.14941606</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">h</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">SimpleQuotients</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">#doctest: +SKIP</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N4</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>                              <span class="c1">#doctest: +SKIP</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">N2</span> <span class="o">==</span> <span class="n">N4</span>                                     <span class="c1">#doctest: +SKIP</span>
<span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cover_info">
<span class="sig-name descname"><span class="pre">cover_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cover_info" title="Link to this definition"></a></dt>
<dd><p>If this is a manifold or triangulation which was constructed as
a covering space, return a dictionary describing the cover.  Otherwise
return 0.  The dictionary keys are ‘base’, ‘type’ and ‘degree’.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.covers">
<span class="sig-name descname"><span class="pre">covers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">degree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cover_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><span class="pre">snappy.Manifold</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#snappy.Manifold.covers" title="Link to this definition"></a></dt>
<dd><p>Returns a list of <a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manifold</span></code></a>s corresponding to all of the
finite covers of the given degree.  The default method is
‘low_index’ for general covers and ‘snappea’ for cyclic
covers.  The former uses Sim’s algorithm while the latter
uses the original Snappea algorithm.</p>
<p>WARNING: If the degree is large this might take a very, very,
very long time.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covers</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">covers</span><span class="p">)</span>
<span class="go">[Z/3 + Z/15 + Z, Z/5 + Z + Z]</span>
</pre></div>
</div>
<p>It is faster to look just at cyclic covers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">covers</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">cover_type</span><span class="o">=</span><span class="s1">&#39;cyclic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">homology</span><span class="p">())</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">covers</span><span class="p">]</span>
<span class="go">[(m003~cyc~0(0,0), Z/3 + Z/15 + Z)]</span>
</pre></div>
</div>
<p>Here we check that we get the same number of covers with the
‘snappea’ and ‘low_index’ methods.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;snappea&#39;</span><span class="p">))</span>
<span class="go">19</span>
</pre></div>
</div>
<p>If you are using Sage, you can use GAP to find the subgroups,
which is often much faster, by specifying the optional
argument method = ‘gap’ If you have Magma installed, you can
used it to do the heavy lifting by specifying method=’magma’.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_area_matrix">
<span class="sig-name descname"><span class="pre">cusp_area_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'maximal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_area_matrix" title="Link to this definition"></a></dt>
<dd><p>Returns the maximal cusp area matrix <span class="math notranslate nohighlight">\((A_{ij})\)</span> where
<span class="math notranslate nohighlight">\(A_{ij}\)</span> is defined as follows.
Let <span class="math notranslate nohighlight">\(C_i\)</span> and <span class="math notranslate nohighlight">\(C_j\)</span> be the (open) cusp neighborhoods about cusp
<span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>. Let <span class="math notranslate nohighlight">\(A(C_i)\)</span> and <span class="math notranslate nohighlight">\(A(C_j)\)</span> be the
areas of <span class="math notranslate nohighlight">\(C_i\)</span> and <span class="math notranslate nohighlight">\(C_j\)</span>, respectively. Then, <span class="math notranslate nohighlight">\(C_i\)</span>
and <span class="math notranslate nohighlight">\(C_j\)</span> are embedded (if <span class="math notranslate nohighlight">\(i = j\)</span>) or disjoint (otherwise)
if and only if <span class="math notranslate nohighlight">\(A(C_i)A(C_j) \leq A_{ij}\)</span>.</p>
<p>Here is an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;L6a5&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_area_matrix</span><span class="p">()</span> 
<span class="go">[27.9999999999996 7.00000000000000 7.00000000000000]</span>
<span class="go">[7.00000000000000 27.9999999999999 7.00000000000000]</span>
<span class="go">[7.00000000000000 7.00000000000000 28.0000000000001]</span>
</pre></div>
</div>
<p><strong>Faster lower bounds</strong></p>
<p>This section can be skipped by most users!</p>
<p>Prior to SnapPy version 3.2, the algorithm to compute the maximal cusp
area matrix was much slower and required <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code> and
SageMath. Thus, in prior versions, <code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code> defaulted to
<code class="docutils literal notranslate"><span class="pre">trigDependentTryCanonize</span></code>. This meant, that, by default,
<a class="reference internal" href="#snappy.Manifold.cusp_area_matrix" title="snappy.Manifold.cusp_area_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cusp_area_matrix()</span></code></a> only returned
(some) lower bounds for the maximal cusp area matrix entries.</p>
<p>These lower bounds can still be accessed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_area_matrix</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;trigDependentTryCanonize&#39;</span><span class="p">)</span> 
<span class="go">[21.4375000000000 7.00000000000000 7.00000000000000]</span>
<span class="go">[7.00000000000000 28.0000000000000 7.00000000000000]</span>
<span class="go">[7.00000000000000 7.00000000000000 28.0000000000000]</span>
</pre></div>
</div>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'trigDependent'</span></code> or
<code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'trigDependenyTryCanonize'</span></code>, the result is triangulation
dependent or not even deterministic, respectively.
Furthermore, if <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code> is also set, while the left
endpoints of the intervals are lower bounds for the maximal cusp area
matrix entries, the right endpoints are meaningless and could be smaller
or larger than the maximal cusp area matrix entries.</p>
<p><strong>Verified computation</strong></p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">False</span></code>, floating-point issues can arise resulting in
incorrect values. The method can be made
<a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified</span></a> by passing <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.cusp_area_matrix(verified=True) # doctest: +NUMERIC3
[       28.0000? 7.000000000000?  7.00000000000?]
[7.000000000000?      28.000000?  7.00000000000?]
[ 7.00000000000?  7.00000000000?       28.00000?]
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verified</strong> – Use <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computation</span></a>.</p></li>
<li><p><strong>bits_prec</strong> – Precision used for computation. Increase if computation
did not succeed or a more precise result is desired.</p></li>
<li><p><strong>method</strong> – Switches to older algorithms giving lower bounds when
<code class="docutils literal notranslate"><span class="pre">trigDependentTryCanonize</span></code> and <code class="docutils literal notranslate"><span class="pre">trigDependent</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Maximal cusp area matrix (default) or lower bounds
(if <code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code> switches to older algorithm).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_areas">
<span class="sig-name descname"><span class="pre">cusp_areas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'unbiased'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'maximal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_cusps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_areas" title="Link to this definition"></a></dt>
<dd><p>Returns a list of areas, one for each cusp. The cusp neighborhoods
defined by these areas are embedded and disjoint. Furthermore, these
neighborhoods are maximal in that they fail to be embedded or
disjoint if any cusp neighborhood is enlarged (unless <code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code>
is set to a value different from the default).</p>
<p>There are different policies how these cusp neighborhoods are found.</p>
<p>The default <code class="xref py py-attr docutils literal notranslate"><span class="pre">policy</span></code> is <code class="docutils literal notranslate"><span class="pre">unbiased</span></code>. This means that the
cusp neighborhoods are blown up simultaneously and a cusp neighborhood
stops growing when it touches any cusp neighborhood including itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;s776&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">()</span> 
<span class="go">[2.64575131106459, 2.64575131106459, 2.64575131106459]</span>
</pre></div>
</div>
<p>Alternatively, <code class="xref py py-attr docutils literal notranslate"><span class="pre">policy='greedy'</span></code> can be specified. This means
that the first cusp neighborhood is blown up until it touches itself,
then the second cusp neighborhood is blown up until it touches itself
or the first cusp neighborhood, and so on:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span> 
<span class="go">[5.29150262212918, 1.32287565553230, 1.32287565553229]</span>
</pre></div>
</div>
<p>Use <code class="xref py py-attr docutils literal notranslate"><span class="pre">first_cusps</span></code> to specify the order in which the cusp
neighborhoods are blown up:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> 
<span class="go">[1.32287565553230, 5.29150262212918, 1.32287565553229]</span>
</pre></div>
</div>
<p>An incomplete list can be given to <code class="xref py py-attr docutils literal notranslate"><span class="pre">first_cusps</span></code>. In this case,
the list is automatically completed by appending the remaining cusps in
order. Thus, the above call is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_areas</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">,</span> <span class="n">first_cusps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
<span class="go">[1.32287565553230, 5.29150262212918, 1.32287565553229]</span>
</pre></div>
</div>
<p>Under the hood, this method is using
<a class="reference internal" href="#snappy.Manifold.cusp_area_matrix" title="snappy.Manifold.cusp_area_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cusp_area_matrix()</span></code></a>.</p>
<p><strong>Verified computation</strong></p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">False</span></code>, floating-point issues can arise resulting in
incorrect values. The method can be made
<a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified</span></a> by passing <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M=Manifold(&quot;s776&quot;)
sage: M.cusp_areas(verified=True) # doctest: +NUMERIC9
[2.64575131107?, 2.64575131107?, 2.64575131107?]
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verified</strong> – Use <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computation</span></a>.</p></li>
<li><p><strong>bits_prec</strong> – Precision used for computation. Increase if computation
did not succeed or a more precise result is desired.</p></li>
<li><p><strong>method</strong> – Passed to <a class="reference internal" href="#snappy.Manifold.cusp_area_matrix" title="snappy.Manifold.cusp_area_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cusp_area_matrix()</span></code></a>. If set
to a value different from the default <code class="docutils literal notranslate"><span class="pre">maximal</span></code>, the cusp
neighborhoods stop growing when the corresponding value
in the computed cusp area matrix is exceeded. At this point,
the cusp neighborhood might not necessarily touch any other
cusp neighborhood since we do not use the maximal cusp area
matrix.</p></li>
<li><p><strong>policy</strong> – Specifies process of choosing cusp neighborhoods.
Either <code class="docutils literal notranslate"><span class="pre">unbiased</span></code> or <code class="docutils literal notranslate"><span class="pre">greedy</span></code>, see above.</p></li>
<li><p><strong>first_cusps</strong> – Preference order of cusps.
Only relevant if <code class="xref py py-attr docutils literal notranslate"><span class="pre">policy='greedy'</span></code>, see above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Areas of maximal embedded and disjoint cusp neighborhoods
(default). Or areas of some embedded and disjoint cusp
neighborhoods (if <code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code> switches to older algorithm).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_info">
<span class="sig-name descname"><span class="pre">cusp_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_spec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_info" title="Link to this definition"></a></dt>
<dd><p>Returns an info object containing information about the given
cusp.   Usage:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;v3227(0,0)(1,2)(3,2)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Cusp 1 : torus cusp with Dehn filling coefficients (M, L) = (1.0, 2.0)</span>
</pre></div>
</div>
<p>To get more detailed information about the cusp, we do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span> 
<span class="go">0.11044502 + 0.94677098*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">modulus</span>
<span class="go">-0.12155872 + 1.04204128*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;filling&#39;, &#39;holonomies&#39;, &#39;holonomy_accuracy&#39;, &#39;index&#39;, &#39;is_complete&#39;, &#39;modulus&#39;, &#39;shape&#39;, &#39;shape_accuracy&#39;, &#39;topology&#39;]</span>
</pre></div>
</div>
<p>Here ‘shape’ is the shape of the cusp, i.e.
(longitude/meridian)
and ‘modulus’ is its shape in the geometrically preferred
basis, i.e.
( (second shortest translation)/(shortest translation)).
For cusps that are filled, one instead cares about the
holonomies:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="s1">&#39;holonomies&#39;</span><span class="p">]</span> 
<span class="go">(-0.59883089 + 1.09812548*I, 0.89824633 + 1.49440443*I)</span>
</pre></div>
</div>
<p>The complex numbers returned for the shape and for the two
holonomies have an extra attribute, accuracy, which is
SnapPea’s <em>estimate</em> of their accuracy.</p>
<p>You can also get information about multiple cusps at once:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">()</span> 
<span class="go">[Cusp 0 : complete torus cusp of shape 0.11044502 + 0.94677098*I,</span>
<span class="go"> Cusp 1 : torus cusp with Dehn filling coefficients (M, L) = (1.0, 2.0),</span>
<span class="go"> Cusp 2 : torus cusp with Dehn filling coefficients (M, L) = (3.0, 2.0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;is_complete&#39;</span><span class="p">)</span>
<span class="go">[True, False, False]</span>
</pre></div>
</div>
<p>The cusp shapes can be verified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&#39;m292&#39;)
sage: M.cusp_info(&#39;shape&#39;, verified = True, bits_prec = 60) # doctest: +NUMERIC12
[-0.1766049820997? + 1.2028208192855?*I,
 -0.1766049820997? + 1.2028208192855?*I]
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_neighborhood">
<span class="sig-name descname"><span class="pre">cusp_neighborhood</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="additional_classes.html#snappy.CuspNeighborhood" title="SnapPy.CuspNeighborhood"><span class="pre">CuspNeighborhood</span></a></span></span><a class="headerlink" href="#snappy.Manifold.cusp_neighborhood" title="Link to this definition"></a></dt>
<dd><p>Returns information about the cusp neighborhoods of the
manifold, in the form of data about the corresponding horoball
diagrams in hyperbolic 3-space.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;s000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cusp_neighborhood</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> 
<span class="go">0.32475953</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">CN</span><span class="o">.</span><span class="n">horoballs</span><span class="p">(</span><span class="mf">0.01</span><span class="p">))</span>
<span class="go">178</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>  <span class="c1"># Opens picture of the horoballs  </span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.cusp_translations">
<span class="sig-name descname"><span class="pre">cusp_translations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'unbiased'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'maximal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_cusps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_translations" title="Link to this definition"></a></dt>
<dd><p>Returns a list of the (complex) Euclidean translations corresponding to the
meridian and longitude of each cusp.</p>
<p>That is, the method uses <a class="reference internal" href="#snappy.Manifold.cusp_areas" title="snappy.Manifold.cusp_areas"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cusp_areas()</span></code></a> to find
(maximal) embedded and disjoint cusp neighborhoods. It then uses the
boundaries of these cusp neighborhoods to measure the meridian and
longitude of each cusp. The result is a pair for each cusp. The first
entry of the pair corresponds to the meridian and is complex. The
second entry corresponds to the longitude and is always real:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;s776&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_translations</span><span class="p">()</span> 
<span class="go">[(0.500000000000000 + 1.32287565553230*I, 2.00000000000000), (0.500000000000000 + 1.32287565553230*I, 2.00000000000000), (0.499999999999999 + 1.32287565553230*I, 2.00000000000000)]</span>
</pre></div>
</div>
<p>It takes the same arguments as <a class="reference internal" href="#snappy.Manifold.cusp_areas" title="snappy.Manifold.cusp_areas"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cusp_areas()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_translations</span><span class="p">(</span><span class="n">policy</span> <span class="o">=</span> <span class="s1">&#39;greedy&#39;</span><span class="p">)</span> 
<span class="go">[(0.70710678118654752440084436210 + 1.8708286933869706927918743662*I, 2.8284271247461900976033774484), (0.35355339059327376220042218105 + 0.93541434669348534639593718308*I, 1.4142135623730950488016887242), (0.35355339059327376220042218105 + 0.93541434669348534639593718308*I, 1.4142135623730950488016887242)]</span>
</pre></div>
</div>
<p><strong>Verified computations</strong></p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">False</span></code>, floating-point issues can arise resulting in
incorrect values. The method can be made
<a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified</span></a> by passing <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.cusp_translations(verified = True) # doctest: +NUMERIC9
[(0.50000000000? + 1.32287565553?*I, 2.00000000000?), (0.500000000000? + 1.32287565554?*I, 2.00000000000?), (0.500000000000? + 1.32287565554?*I, 2.00000000000?)]
</pre></div>
</div>
<p>Note that the first element of each pair is a SageMath <code class="docutils literal notranslate"><span class="pre">ComplexIntervalField</span></code> and
the second element a <code class="docutils literal notranslate"><span class="pre">RealIntervalField</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.dehn_fill">
<span class="sig-name descname"><span class="pre">dehn_fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filling_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which_cusp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#snappy.Manifold.dehn_fill" title="Link to this definition"></a></dt>
<dd><p>Set the Dehn filling coefficients of the cusps.  This can be
specified in the following ways, where the cusps are numbered
by 0,1,…,(num_cusps - 1).</p>
<ul>
<li><p>Fill cusp 2:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;8^4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(0,0)(0,0)(2,3)(0,0)</span>
</pre></div>
</div>
</li>
<li><p>Fill the last cusp:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(0,0)(0,0)(2,3)(1,5)</span>
</pre></div>
</div>
</li>
<li><p>Fill the first two cusps:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(3,0)(1,-4)(2,3)(1,5)</span>
</pre></div>
</div>
</li>
<li><p>When there is only one cusp, there’s a shortcut</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">m004(-3,4)</span>
</pre></div>
</div>
</li>
</ul>
<p>Does not return a new Manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.dirichlet_domain">
<span class="sig-name descname"><span class="pre">dirichlet_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex_epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">displacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid_at_origin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximize_injectivity_radius</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_words</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="additional_classes.html#snappy.DirichletDomain" title="SnapPy.DirichletDomain"><span class="pre">DirichletDomain</span></a></span></span><a class="headerlink" href="#snappy.Manifold.dirichlet_domain" title="Link to this definition"></a></dt>
<dd><p>Returns a <a class="reference internal" href="additional_classes.html#snappy.DirichletDomain" title="snappy.DirichletDomain"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirichletDomain</span></code></a> object representing a Dirichlet
domain of the hyperbolic manifold, typically centered at a
point which is a local maximum of injectivity radius.  It will
have ideal vertices if the manifold is not closed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">32 finite vertices, 2 ideal vertices; 54 edges; 22 faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>   <span class="c1">#Shows 3d-graphical view.  </span>
</pre></div>
</div>
<p>The group elements for the face-pairings of the Dirichlet domain
can be given as words in the original generators of the
(unsimplified) fundamental group by setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">include_words</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">(</span><span class="n">include_words</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">pairing_words</span><span class="p">())</span> 
<span class="go">[&#39;A&#39;, ...]</span>
</pre></div>
</div>
<p>Other options can be provided to customize the computation;
the default choices are shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">(</span><span class="n">vertex_epsilon</span><span class="o">=</span><span class="mf">10.0</span><span class="o">**-</span><span class="mi">8</span><span class="p">,</span>
<span class="gp">... </span>   <span class="n">displacement</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="gp">... </span>   <span class="n">centroid_at_origin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maximize_injectivity_radius</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">32 finite vertices, 2 ideal vertices; 54 edges; 22 faces</span>
</pre></div>
</div>
<p>Here’s one with different combinatorics:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">(</span><span class="n">displacement</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="n">maximize_injectivity_radius</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span>
<span class="go">44 finite vertices, 1 ideal vertices; 69 edges; 26 faces</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.drill">
<span class="sig-name descname"><span class="pre">drill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">which_curve</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.drill" title="Link to this definition"></a></dt>
<dd><p>Drills out the specified dual curve from among all dual curves
with at most max_segments, which defaults to 6. The method
dual_curve allows one to see the properties of curves before
choosing which one to drill out.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;v3000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_segments</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">(),</span> <span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">())</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.drill_word">
<span class="sig-name descname"><span class="pre">drill_word</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">word</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><span class="pre">Manifold</span></a></span></span><a class="headerlink" href="#snappy.Manifold.drill_word" title="Link to this definition"></a></dt>
<dd><p>Drills the geodesic corresponding to the given word in the unsimplified
fundamental group. Here is an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">length_spectrum_alt</span><span class="p">(</span><span class="n">max_len</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span> 
<span class="go">[Length                                      Core curve  Word</span>
<span class="go"> 1.08707014499574 + 1.72276844987009*I       -           bC,</span>
<span class="go"> 1.08707014499574 - 1.72276844987009*I       -           a]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill_word</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">identify</span><span class="p">()</span>
<span class="go">[m129(0,0)(0,0), 5^2_1(0,0)(0,0), L5a1(0,0)(0,0), ooct01_00001(0,0)(0,0)]</span>
</pre></div>
</div>
<p>The last cusp of the resulting manifold corresponds to the drilled
geodesic. The longitude and meridian for that cusp are chosen such that
<code class="docutils literal notranslate"><span class="pre">(1,0)</span></code>-filling the last cusp results in the given (undrilled) manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="s1">&#39;core_length&#39;</span><span class="p">]</span> 
<span class="go">1.08707014499574 - 1.72276844987009*I</span>
</pre></div>
</div>
<p>The orientation of the new longitude is chosen so that it is parallel to
the closed geodesic. That is, the new longitude is homotopic to the closed
geodesic when embedding the drilled manifold into the given manifold.</p>
<p>If the given geodesic coincides with a core curve of a filled cusp, the
cusp is unfilled instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004(2,3)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> 
<span class="go">1.73712388065</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="s1">&#39;core_length&#39;</span><span class="p">]</span> 
<span class="go">0.178792491242577 - 2.11983007979743*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="n">simplify_presentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">complex_length</span><span class="p">(</span><span class="s1">&#39;aBAbbABab&#39;</span><span class="p">)</span> 
<span class="go">0.178792491242577 - 2.11983007979743*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill_word</span><span class="p">(</span><span class="s1">&#39;aBAbbABab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">m004_drilled(0,0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>In this case, the peripheral information is also
updated such that the above remark about <code class="docutils literal notranslate"><span class="pre">(1,0)</span></code>-filling applies again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> 
<span class="go">1.73712388065</span>
</pre></div>
</div>
<p>That is, the longitude and meridian of the unfilled cusps are reinstalled
and the cusps reindexed so that the unfilled cusp becomes the last cusp.</p>
<p>Here is another example where we drill the core geodesic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;v2986(3,4)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill_word</span><span class="p">(</span><span class="s1">&#39;EdFgabcGEdFgaDcc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;v2986&quot;</span><span class="p">),</span> <span class="n">return_isometries</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> 
<span class="go">[0 -&gt; 0</span>
<span class="go"> [3 -1]</span>
<span class="go"> [4 -1]</span>
<span class="go"> Does not extend to link]</span>
</pre></div>
</div>
<p>While the result of drilling a geodesic is a triangulation and thus
combinatorial in nature, some intermediate computations (for example,
to compute the intersections of the geodesic with the faces of the
tetrahedra) are numerical. Sometimes, it is necessary to increase the
precision with <code class="xref py py-attr docutils literal notranslate"><span class="pre">bits_prec</span></code> to make the method succeed and produce
the correct result.</p>
<p><strong>Verified computation</strong></p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">False</span></code>, floating-point issues can arise resulting
in drilling the wrong loop. The method can be made
<a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified</span></a> by passing <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004(2,3)&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">drill_word</span><span class="p">(</span><span class="s1">&#39;caa&#39;</span><span class="p">,</span> <span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">bits_prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">m004_drilled</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, if the precision is insufficient to prove the result is correct,
the algorithm fails with an exception (most likely
<code class="docutils literal notranslate"><span class="pre">InsufficientPrecisionError</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>word</strong> – The word in the unsimplified fundamental group specifying the
geodesic to be drilled.</p></li>
<li><p><strong>bits_prec</strong> – The precision used in the intermediate computation. Increase
if the computation failed.</p></li>
<li><p><strong>verified</strong> – Use <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computation</span></a>.</p></li>
<li><p><strong>verbose</strong> – Print intermediate results and statistics.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Manifold obtained by drilling geodesic. <code class="docutils literal notranslate"><span class="pre">(1,0)</span></code>-filling the
last cusp gives the given (undrilled) manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.drill_words">
<span class="sig-name descname"><span class="pre">drill_words</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">words</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><span class="pre">Manifold</span></a></span></span><a class="headerlink" href="#snappy.Manifold.drill_words" title="Link to this definition"></a></dt>
<dd><p>A generalization of <a class="reference internal" href="#snappy.Manifold.drill_word" title="snappy.Manifold.drill_word"><code class="xref py py-meth docutils literal notranslate"><span class="pre">drill_word</span></code></a> to drill
several geodesics simultaneously. It takes a list of words in the
unsimplified fundamental group.</p>
<p>Here is an example where we drill two geodesics. One of the geodesics is
the core curve corresponding to the third cusp. The other geodesic is not
a core curve:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;t12047(0,0)(1,3)(1,4)(1,5)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;core_length&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">()</span> <span class="p">]</span> 
<span class="go">[None,</span>
<span class="go"> 0.510804267610103 + 1.92397456664239*I,</span>
<span class="go"> 0.317363079597924 + 1.48157893409218*I,</span>
<span class="go"> 0.223574975263386 + 1.26933288854145*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="n">simplify_presentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">complex_length</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span> 
<span class="go">0.317363079597924 + 1.48157893409218*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">complex_length</span><span class="p">(</span><span class="s1">&#39;fA&#39;</span><span class="p">)</span> 
<span class="go">1.43914411734250 + 2.66246879992795*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill_words</span><span class="p">([</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;fA&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">t12047_drilled(0,0)(1,3)(1,5)(0,0)(0,0)</span>
</pre></div>
</div>
<p>Let n be the number of geodesics that were drilled. Then the last n
cusps correspond to the drilled geodesics and appear in the same order than
the geodesics were given as words. Note that in the above example, we expect
six cusps since we started with four cusps and drilled two geodesics. However,
we only obtain five cusps because one geodesic was a core curve. The
corresponding cusp was unfilled (from <code class="docutils literal notranslate"><span class="pre">(1,4)</span></code>) and grouped with the other
cusps coming from drilling.</p>
<p>We obtain the given (undrilled) manifold by <code class="docutils literal notranslate"><span class="pre">(1,0)</span></code>-filling the last n
cusps.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;core_length&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">()</span> <span class="p">]</span> 
<span class="go">[None,</span>
<span class="go"> 0.510804267610103 + 1.92397456664239*I,</span>
<span class="go"> 0.223574975263386 + 1.26933288854145*I,</span>
<span class="go"> 0.317363079597924 + 1.48157893409218*I,</span>
<span class="go"> 1.43914411734251 + 2.66246879992796*I]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>word</strong> – The words in the unsimplified fundamental group specifying the
geodesics to be drilled.</p></li>
<li><p><strong>bits_prec</strong> – The precision used in the intermediate computation. Increase
if the computation failed.</p></li>
<li><p><strong>verified</strong> – Use <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computation</span></a>.</p></li>
<li><p><strong>verbose</strong> – Print intermediate results and statistics.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Manifold obtained by drilling geodesics. <code class="docutils literal notranslate"><span class="pre">(1,0)</span></code>-filling the
last n cusps gives the given (undrilled) manifold where n is the
number of given words.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.dual_curves">
<span class="sig-name descname"><span class="pre">dual_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.dual_curves" title="Link to this definition"></a></dt>
<dd><p>Constructs a <em>reasonable</em> selection of simple closed curves in
a manifold’s dual 1-skeleton.  In particular, it returns those
that appear to represent geodesics. The resulting curves can
be drilled out.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curves</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dual_curves</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curves</span> 
<span class="go">[  0: orientation-preserving curve of length 0.56239915 - 2.81543089*I,</span>
<span class="go">   1: orientation-preserving curve of length 1.12479830 + 0.65232354*I,</span>
<span class="go">   2: orientation-preserving curve of length 1.26080402 + 1.97804689*I,</span>
<span class="go">   3: orientation-preserving curve of length 1.58826933 + 1.67347167*I,</span>
<span class="go">   4: orientation-preserving curve of length 1.68719745 + 2.81543089*I]</span>
</pre></div>
</div>
<p>Each curve is returned as an info object with these keys</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;complete_length&#39;, &#39;filled_length&#39;, &#39;index&#39;, &#39;max_segments&#39;, &#39;parity&#39;]</span>
</pre></div>
</div>
<p>We can drill out any of these curves to get a new manifold
with one more cusp.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">(),</span> <span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">())</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>By default, this function only finds curves of length 6; this
can be changed by specifying the optional argument
max_segments</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dual_curves</span><span class="p">(</span><span class="n">max_segments</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">[  0: orientation-preserving curve of length 0.56239915 - 2.81543089*I]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.edge_valences">
<span class="sig-name descname"><span class="pre">edge_valences</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.edge_valences" title="Link to this definition"></a></dt>
<dd><p>Returns a dictionary whose keys are the valences of the edges
in the triangulation, and the value associated to a key is the
number of edges of that valence.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;v3227&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">edge_valences</span><span class="p">()</span>     
<span class="go">{10: 1, 4: 1, 5: 2, 6: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.exterior_to_link">
<span class="sig-name descname"><span class="pre">exterior_to_link</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_answer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">careful_perturbation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify_link</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pachner_search_tries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="spherogram.html#spherogram.Link" title="spherogram.Link"><span class="pre">Link</span></a></span></span><a class="headerlink" href="#snappy.Manifold.exterior_to_link" title="Link to this definition"></a></dt>
<dd><p>For a triangulation of the exterior of a link in the 3-sphere,
return a planar diagram for the link.  The peripheral curves whose
Dehn filling is the 3-sphere are <strong>part of the input</strong>, specified
by either:</p>
<ol class="loweralpha simple">
<li><p>If no cusp is filled, then they are the meridians of the
current peripheral curves.</p></li>
<li><p>If every cusp is filled, then they are the current Dehn filling
curves.</p></li>
</ol>
<p>In particular, it does <strong>not</strong> try to determine whether there exist
fillings on the input which give the 3-sphere.  Example usage:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m016&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">exterior_to_link</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">exterior</span><span class="p">()</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The algorithm used is that of <a class="reference external" href="https://arxiv.org/abs/2112.03251">Dunfield, Obeidin, and Rudd</a>.  The optional arguments are
as follows.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code>: When <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints progress updates as the algorithm
goes along.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_input</span></code>: When <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default), first checks that the
fundamental group of the specified Dehn filling is trivial.  As
it doesn’t try too hard to simplify the group presentation, it
can happen that this check fails but the algorithm still finds a
diagram if you pass <code class="docutils literal notranslate"><span class="pre">check_input=False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_answer</span></code>: When <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default), take the exterior of
the final link diagram and use <code class="docutils literal notranslate"><span class="pre">Manifold.is_isometric_to</span></code> to
confirm that it is homeomorphic to the input.  If the input is
not hyperbolic or is very large, this check may fail even though
the diagram is correct.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">careful_perturbation</span></code>: The rational coordinates of the
intermediate PL links are periodically rounded to control the
size of their denominators.  When <code class="docutils literal notranslate"><span class="pre">careful_perturbation=True</span></code>
(the default), computations are performed to ensure this
rounding does not change the isotopy class of the link.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">simplify_link</span></code>: When <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default), uses
<code class="docutils literal notranslate"><span class="pre">Link.simplify('global')</span></code> to minimize the size of the final
diagram; otherwise, it just does <code class="docutils literal notranslate"><span class="pre">basic</span></code> simplifications, which
can be much faster if the initial link is complicated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pachner_search_tries</span></code>: Controls how hard to search for a
suitable sequence of Pachner moves from the filled input
triangulation to a standard triangulation of the 3-sphere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seed</span></code>: The algorithm involves many random choices, and hence
each run typically produces a different diagram of the
underlying link.  If you need the same output each time, you can
specify a fixed seed for the various pseudo-random number
generators.</p></li>
</ul>
<p>Note on rigor: Provided at least one of <code class="docutils literal notranslate"><span class="pre">check_answer</span></code> and
<code class="docutils literal notranslate"><span class="pre">careful_perturbation</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the exterior of the output
link is guaranteed to match the input (including the choice of
meridians).</p>
<p><strong>Warning:</strong> The order of the link components and the cusps of the
input manifold is only guaranteed to match when
<code class="docutils literal notranslate"><span class="pre">check_answer=True</span></code>.  Even then, the implicit orientation along
each component of the link may not be preserved.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.filled_triangulation">
<span class="sig-name descname"><span class="pre">filled_triangulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cusps_to_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><span class="pre">snappy.Manifold</span></a></span></span><a class="headerlink" href="#snappy.Manifold.filled_triangulation" title="Link to this definition"></a></dt>
<dd><p>Return a new Manifold where the specified cusps have been
permanently filled in.</p>
<p>Filling all the cusps results in a Triangulation rather
than a Manifold, since SnapPea can’t deal with hyperbolic
structures when there are no cusps.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125(1,2)(3,4)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Filling cusps 0 and 2 :</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;v3227(1,2)(3,4)(5,6)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">v3227_filled(3,4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.fundamental_group">
<span class="sig-name descname"><span class="pre">fundamental_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">simplify_presentation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillings_may_affect_generators</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimize_number_of_generators</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">try_hard_to_shorten_relators</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="additional_classes.html#snappy.HolonomyGroup" title="SnapPy.HolonomyGroup"><span class="pre">HolonomyGroup</span></a></span></span><a class="headerlink" href="#snappy.Manifold.fundamental_group" title="Link to this definition"></a></dt>
<dd><p>Return a <a class="reference internal" href="additional_classes.html#snappy.HolonomyGroup" title="snappy.HolonomyGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">HolonomyGroup</span></code></a> representing the fundamental group of
the manifold, together with its holonomy representation.  If
integer Dehn surgery parameters have been set, then the
corresponding peripheral elements are killed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span>
<span class="go">Generators:</span>
<span class="go">   a,b</span>
<span class="go">Relators:</span>
<span class="go">   aaabABBAb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">peripheral_curves</span><span class="p">()</span>
<span class="go">[(&#39;ab&#39;, &#39;aBAbABab&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">SL2C</span><span class="p">(</span><span class="s1">&#39;baaBA&#39;</span><span class="p">)</span> 
<span class="go">[ 2.50000000 - 2.59807621*I -6.06217783 - 0.50000000*I]</span>
<span class="go">[ 0.86602540 - 2.50000000*I -4.00000000 + 1.73205081*I]</span>
</pre></div>
</div>
<p>There are three optional arguments all of which default to True:</p>
<ul class="simple">
<li><p>simplify_presentation</p></li>
<li><p>fillings_may_affect_generators</p></li>
<li><p>minimize_number_of_generators</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">Generators:</span>
<span class="go">   a,b,c</span>
<span class="go">Relators:</span>
<span class="go">   CbAcB</span>
<span class="go">   BacA</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.gluing_equations">
<span class="sig-name descname"><span class="pre">gluing_equations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">form</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'log'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.gluing_equations" title="Link to this definition"></a></dt>
<dd><p>In the default mode, this function returns a matrix with rows
of the form</p>
<blockquote>
<div><p>a b c  d e f  …</p>
</div></blockquote>
<p>which means</p>
<blockquote>
<div><p>a*log(z0) + b*log(1/(1-z0)) + c*log((z0-1)/z0) + d*log(z1) +… = 2 pi i</p>
</div></blockquote>
<p>for an edge equation, and (same) = 0 for a cusp equation.
Here, the cusp equations come at the bottom of the matrix, and
are listed in the form: meridian of cusp 0, longitude of cusp
0, meridian of cusp 1, longitude of cusp 1,…</p>
<p>In terms of the tetrahedra, a is the invariant of the edge
(2,3), b the invariant of the edge (0,2) and c is the
invariant of the edge (1,2).  See kernel_code/edge_classes.c
for a detailed account of the convention used.</p>
<p>If the optional argument form=’rect’ is given, then this
function returns a list of tuples of the form:</p>
<blockquote>
<div><p>( [a0, a1,..,a_n], [b_0, b_1,…,b_n], c)</p>
</div></blockquote>
<p>where this corresponds to the equation</p>
<blockquote>
<div><p>z0^a0 (1 - z0)^b0 z1^a1(1 - z1)^b1 …  = c</p>
</div></blockquote>
<p>where c = 1 or -1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004(2,3)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations</span><span class="p">()</span>
<span class="go">[ 2  1  0  1  0  2]</span>
<span class="go">[ 0  1  2  1  2  0]</span>
<span class="go">[ 2  0  0  0 -8  6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations</span><span class="p">(</span><span class="n">form</span><span class="o">=</span><span class="s1">&#39;rect&#39;</span><span class="p">)</span>
<span class="go">[([2, -1], [-1, 2], 1), ([-2, 1], [1, -2], 1), ([2, -6], [0, 14], 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.gluing_equations_pgl">
<span class="sig-name descname"><span class="pre">gluing_equations_pgl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.gluing_equations_pgl" title="Link to this definition"></a></dt>
<dd><p>Returns a NeumannZagierTypeEquations object that contains a matrix
encoding the gluing equations for boundary-parabolic PGL(N,C)
representations together with explanations of the meaning
of the rows and the columns of the matrix.</p>
<p>This method generalizes gluing_equations() to PGL(N,C)-representations
as described in
Stavros Garoufalidis, Matthias Goerner, Christian K. Zickert:
“Gluing Equations for PGL(n,C)-Representations of 3-Manifolds”
(<a class="reference external" href="http://arxiv.org/abs/1207.6711">http://arxiv.org/abs/1207.6711</a>).</p>
<p>The result of the <a class="reference internal" href="#snappy.Manifold.gluing_equations" title="snappy.Manifold.gluing_equations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gluing_equations()</span></code></a> can be obtained from
the general method by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">()</span><span class="o">.</span><span class="n">matrix</span>
<span class="go">[ 2  1  0  1  0  2]</span>
<span class="go">[ 0  1  2  1  2  0]</span>
<span class="go">[ 1  0  0  0 -1  0]</span>
<span class="go">[ 0  0  0  0 -2  2]</span>
</pre></div>
</div>
<p>But besides the matrix, the method also returns explanations of
the columns and rows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">()</span>
<span class="go">NeumannZagierTypeEquations(</span>
<span class="go">  [ 2  1  0  1  0  2]</span>
<span class="go">  [ 0  1  2  1  2  0]</span>
<span class="go">  [ 1  0  0  0 -1  0]</span>
<span class="go">  [ 0  0  0  0 -2  2],</span>
<span class="go">  explain_columns = [&#39;z_0000_0&#39;, &#39;zp_0000_0&#39;, &#39;zpp_0000_0&#39;, &#39;z_0000_1&#39;, &#39;zp_0000_1&#39;, &#39;zpp_0000_1&#39;],</span>
<span class="go">  explain_rows = [&#39;edge_0_0&#39;, &#39;edge_0_1&#39;, &#39;meridian_0_0&#39;, &#39;longitude_0_0&#39;])</span>
</pre></div>
</div>
<p>The first row of the matrix means that the edge equation for
edge 0 is</p>
<div class="math notranslate nohighlight">
\[{z_{0000,0}}^2 * z'_{0000,0} * z_{0000,1} * {z''_{0000,1}}^2 = 1.\]</div>
<p>Similarly, the next row encodes the edge equation for the other edge
and the next two rows encode peripheral equations.</p>
<p>Following the SnapPy convention, a <code class="docutils literal notranslate"><span class="pre">z</span></code> denotes the cross ratio
<span class="math notranslate nohighlight">\(z\)</span> at the edge (0,1), a <code class="docutils literal notranslate"><span class="pre">zp</span></code> the cross ratio <span class="math notranslate nohighlight">\(z'\)</span> at
the edge (0,2) and a <code class="docutils literal notranslate"><span class="pre">zpp</span></code> the cross
ratio <span class="math notranslate nohighlight">\(z''\)</span> at the edge (1,2). The entire symbol <code class="docutils literal notranslate"><span class="pre">z_xxxx_y</span></code> then
denotes the cross ratio belonging to the subsimplex at integral
point <code class="docutils literal notranslate"><span class="pre">xxxx</span></code> (always <code class="docutils literal notranslate"><span class="pre">0000</span></code> for <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">2</span></code>) of the simplex <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>Note: the SnapPy convention is different from the paper
mentioned above, e.g., compare
kernel_code/edge_classes.c with Figure 3. We follow the SnapPy
convention here so that all computations done in SnapPy are
consistent.</p>
<p>The explanations of the rows and columns can be obtained explicitly by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">equation_type</span> <span class="o">=</span> <span class="s1">&#39;peripheral&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">explain_rows</span>
<span class="go">[&#39;meridian_0_0&#39;, &#39;meridian_1_0&#39;, &#39;longitude_0_0&#39;, &#39;longitude_1_0&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">explain_columns</span>
<span class="go">[&#39;z_0000_0&#39;, &#39;zp_0000_0&#39;, &#39;zpp_0000_0&#39;, &#39;z_0000_1&#39;, &#39;zp_0000_1&#39;, &#39;zpp_0000_1&#39;]</span>
</pre></div>
</div>
<p>A subset of all gluing equations can be obtained by setting the
<code class="docutils literal notranslate"><span class="pre">equation_type</span></code>:</p>
<ul class="simple">
<li><p>all gluing equations: <code class="docutils literal notranslate"><span class="pre">all</span></code></p></li>
<li><p>non-peripheral equations: <code class="docutils literal notranslate"><span class="pre">non_peripheral</span></code></p>
<ul>
<li><p>edge gluing equations: <code class="docutils literal notranslate"><span class="pre">edge</span></code></p></li>
<li><p>face gluing equations: <code class="docutils literal notranslate"><span class="pre">face</span></code></p></li>
<li><p>internal gluing equations: <code class="docutils literal notranslate"><span class="pre">internal</span></code></p></li>
</ul>
</li>
<li><p>cusp gluing equations: <code class="docutils literal notranslate"><span class="pre">peripheral</span></code></p>
<ul>
<li><p>cusp gluing equations for meridians: <code class="docutils literal notranslate"><span class="pre">meridian</span></code></p></li>
<li><p>cusp gluing equations for longitudes: <code class="docutils literal notranslate"><span class="pre">longitude</span></code></p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.has_finite_vertices">
<span class="sig-name descname"><span class="pre">has_finite_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#snappy.Manifold.has_finite_vertices" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if the triangulation has finite (non-ideal)
vertices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When trying to find a hyperbolic structure, SnapPea will eliminate
finite vertices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">with_hyperbolic_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">has_finite_vertices</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.high_precision">
<span class="sig-name descname"><span class="pre">high_precision</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.high_precision" title="Link to this definition"></a></dt>
<dd><p>Return a high precision version of this manifold.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">high_precision</span><span class="p">())</span>
<span class="go">&lt;class &#39;snappy.ManifoldHP&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.holonomy_matrix_entries">
<span class="sig-name descname"><span class="pre">holonomy_matrix_entries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.holonomy_matrix_entries" title="Link to this definition"></a></dt>
<dd><p>The entries of the matrices of the holonomy as list of ApproximateAlgebraicNumbers
(four consecutive numbers per matrix). The numbers are guaranteed to lie in the
trace field only if match_kernel = False:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">mat_entries</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">holonomy_matrix_entries</span><span class="p">(</span><span class="n">match_kernel</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE +NUMERIC9</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">mat_entries</span>
<span class="o">&lt;</span><span class="n">SetOfAAN</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.8660254037844386</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.8660254037844386</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.8660254037844386</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1.7320508075688772</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">3.4641016151377544</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">1.7320508075688772</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1.7320508075688772</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.7320508075688772</span><span class="o">*</span><span class="n">I</span><span class="p">]</span><span class="o">&gt;</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span> <span class="o">=</span> <span class="n">mat_entries</span><span class="o">.</span><span class="n">find_field</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">optimize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">polynomial</span><span class="p">()</span>
<span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.homological_longitude">
<span class="sig-name descname"><span class="pre">homological_longitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cusp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.homological_longitude" title="Link to this definition"></a></dt>
<dd><p>Returns the peripheral curve in the given cusp, if any, which is
homologically trivial (with rational coefficients) in the manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">homological_longitude</span><span class="p">()</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>If no cusp is specified, the default is the first unfilled cusp;
if all cusps are filled, the default is the first cusp:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L5a1(3,4)(0,0)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">homological_longitude</span><span class="p">()</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The components of the next link have nontrivial linking number
so there is no such curve:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">W</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L7a2&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">W</span><span class="o">.</span><span class="n">homological_longitude</span><span class="p">(</span><span class="n">cusp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="kc">True</span>
</pre></div>
</div>
<p>If every curve in the given cusp is trivial in the rational homology of
the manifold, an exception is raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;4_1(1,0)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">homological_longitude</span><span class="p">()</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="o">...</span>
<span class="ne">ValueError</span><span class="p">:</span> <span class="n">Every</span> <span class="n">curve</span> <span class="n">on</span> <span class="n">cusp</span> <span class="ow">is</span> <span class="n">homologically</span> <span class="n">trivial</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.homology">
<span class="sig-name descname"><span class="pre">homology</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="additional_classes.html#snappy.AbelianGroup" title="SnapPy.AbelianGroup"><span class="pre">AbelianGroup</span></a></span></span><a class="headerlink" href="#snappy.Manifold.homology" title="Link to this definition"></a></dt>
<dd><p>Returns an <a class="reference internal" href="additional_classes.html#snappy.AbelianGroup" title="snappy.AbelianGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbelianGroup</span></code></a> representing the first integral
homology group of the underlying (Dehn filled) manifold.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">Z/5 + Z</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.hyperbolic_SLN_torsion">
<span class="sig-name descname"><span class="pre">hyperbolic_SLN_torsion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_SLN_torsion" title="Link to this definition"></a></dt>
<dd><p>Compute the torsion polynomial of the holonomy representation lifted
to SL(2, C) and then followed by the irreducible representation
from SL(2, C) -&gt; SL(N, C):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m016&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="p">[</span><span class="n">M</span><span class="o">.</span><span class="n">hyperbolic_SLN_torsion</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">36</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.hyperbolic_adjoint_torsion">
<span class="sig-name descname"><span class="pre">hyperbolic_adjoint_torsion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_adjoint_torsion" title="Link to this definition"></a></dt>
<dd><p>Computes the torsion polynomial of the adjoint representation
a la Dubois-Yamaguichi.   This is not a sign-refined computation
so the result is only defined up to sign, not to mention a power
of the variable ‘a’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K11n42&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">hyperbolic_adjoint_torsion</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="n">Univariate</span> <span class="n">Polynomial</span> <span class="n">Ring</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">over</span> <span class="n">Complex</span> <span class="n">Field</span> <span class="k">with</span> <span class="mi">100</span> <span class="n">bits</span> <span class="n">of</span> <span class="n">precision</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="mi">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.hyperbolic_torsion">
<span class="sig-name descname"><span class="pre">hyperbolic_torsion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_lifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wada_conventions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_torsion" title="Link to this definition"></a></dt>
<dd><p>Computes the hyperbolic torsion polynomial as defined in
<a class="reference external" href="http://arxiv.org/abs/1108.3045">[DFJ]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K11n42&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">()</span>
<span class="mi">1</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">hyperbolic_torsion</span><span class="p">(</span><span class="n">bits_prec</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">tau</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="mi">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.identify">
<span class="sig-name descname"><span class="pre">identify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extends_to_link</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.identify" title="Link to this definition"></a></dt>
<dd><p>Looks for the manifold in all of the SnapPy databases.
For hyperbolic manifolds this is done by searching for isometries:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">identify</span><span class="p">()</span>
<span class="go">[m125(0,0)(0,0), L13n5885(0,0)(0,0), ooct01_00000(0,0)(0,0)]</span>
</pre></div>
</div>
<p>By default, there is no restriction on the isometries. One can
require that the isometry take meridians to meridians. This
might return fewer results:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="n">extends_to_link</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[m125(0,0)(0,0), ooct01_00000(0,0)(0,0)]</span>
</pre></div>
</div>
<p>For closed manifolds, extends_to_link doesn’t make sense
because of how the kernel code works:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m015(1,2)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">identify</span><span class="p">()</span>
<span class="go">[m006(-5,2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.inside_view">
<span class="sig-name descname"><span class="pre">inside_view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cohomology_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geodesics</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.inside_view" title="Link to this definition"></a></dt>
<dd><p>Show raytraced inside view of hyperbolic manifold. See
<a class="reference external" href="https://im.icerm.brown.edu/portfolio/snappy-views/">images</a>
and <a class="reference external" href="https://youtu.be/CAERhmUCkRs">demo video</a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">inside_view</span><span class="p">()</span> 
</pre></div>
</div>
<p>Or show the cohomology fractal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">inside_view</span><span class="p">(</span><span class="n">cohomology_class</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> 
</pre></div>
</div>
<p>The cohomology class in <span class="math notranslate nohighlight">\(H^2(M, \partial M; \mathbb{R})\)</span> producing the
cohomology fractal can be specified as a cocycle or using an automatically
computed basis (of, say, length <code class="docutils literal notranslate"><span class="pre">n</span></code>). Thus, <code class="docutils literal notranslate"><span class="pre">cohomology_class</span></code> can be
one of the following.</p>
<ul class="simple">
<li><p>An integer <code class="docutils literal notranslate"><span class="pre">i</span></code> between 0 and <code class="docutils literal notranslate"><span class="pre">n</span></code> - 1 to pick the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th basis
vector.</p></li>
<li><p>An array of length <code class="docutils literal notranslate"><span class="pre">n</span></code> specifying the cohomology class as linear
combination of basis vectors.</p></li>
<li><p>A weight for each face of each tetrahedron.</p></li>
</ul>
<p>Geodesics can be specified as words in the unsimplified fundamental group:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">inside_view</span><span class="p">(</span><span class="n">geodesics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;bC&#39;</span><span class="p">])</span> 
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.invariant_trace_field_gens">
<span class="sig-name descname"><span class="pre">invariant_trace_field_gens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.invariant_trace_field_gens" title="Link to this definition"></a></dt>
<dd><p>The generators of the trace field as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m007(3,1)&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">invariant_trace_field_gens</span><span class="p">()</span><span class="o">.</span><span class="n">find_field</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">L</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">trace_field_gens</span><span class="p">()</span><span class="o">.</span><span class="n">find_field</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">K</span><span class="o">.</span><span class="n">polynomial</span><span class="p">(),</span> <span class="n">L</span><span class="o">.</span><span class="n">polynomial</span><span class="p">()</span>
<span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.is_isometric_to">
<span class="sig-name descname"><span class="pre">is_isometric_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><span class="pre">Manifold</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ManifoldHP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_isometries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Isometry</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#snappy.Manifold.is_isometric_to" title="Link to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if M and N are isometric, <code class="docutils literal notranslate"><span class="pre">False</span></code> if they not.
A <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> is raised in cases where the SnapPea kernel fails
to determine either answer.  (This is fairly common for closed
manifolds.)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can also get a complete list of isometries between the two
manifolds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5^2_1&#39;</span><span class="p">)</span>  <span class="c1"># The Whitehead link</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m129&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">return_isometries</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># Includes action on cusps</span>
<span class="go">0 -&gt; 1  1 -&gt; 0</span>
<span class="go">[1  2]  [-1 -2]</span>
<span class="go">[0 -1]  [ 0  1]</span>
<span class="go">Extends to link</span>
</pre></div>
</div>
<p>Each transformation between cusps is given by a matrix which
acts on the left.  That is, the two <em>columns</em> of the matrix
give the image of the meridian and longitude respectively.  In
the above example, the meridian of cusp 0 is sent to the
meridian of cusp 1.</p>
<p>Note: The answer <code class="docutils literal notranslate"><span class="pre">True</span></code> is rigorous, but the answer <code class="docutils literal notranslate"><span class="pre">False</span></code> may
not be as there could be numerical errors resulting in finding
an incorrect canonical triangulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.is_orientable">
<span class="sig-name descname"><span class="pre">is_orientable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#snappy.Manifold.is_orientable" title="Link to this definition"></a></dt>
<dd><p>Return whether the underlying 3-manifold is orientable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;x124&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.is_two_bridge">
<span class="sig-name descname"><span class="pre">is_two_bridge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#snappy.Manifold.is_two_bridge" title="Link to this definition"></a></dt>
<dd><p>If the manifold is the complement of a two-bridge knot or link
in <span class="math notranslate nohighlight">\(S^3\)</span>, then this method returns <span class="math notranslate nohighlight">\((p,q)\)</span> where
<span class="math notranslate nohighlight">\(p/q\)</span> is the fraction describing the link.
Otherwise, returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_two_bridge</span><span class="p">()</span>
<span class="go">(2, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m016&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_two_bridge</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note: An answer of <code class="docutils literal notranslate"><span class="pre">True</span></code> is rigorous, but not the answer
<code class="docutils literal notranslate"><span class="pre">False</span></code>, as there could be numerical errors resulting in
finding an incorrect canonical triangulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.isometry_signature">
<span class="sig-name descname"><span class="pre">isometry_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">of_link</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval_bits_precs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[53,</span> <span class="pre">212]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_bits_prec_and_degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[(212,</span> <span class="pre">10),</span> <span class="pre">(1000,</span> <span class="pre">20),</span> <span class="pre">(2000,</span> <span class="pre">20)]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#snappy.Manifold.isometry_signature" title="Link to this definition"></a></dt>
<dd><p>Returns the “isometry signature”, a complete invariant of the hyperbolic
3-manifold obtained by applying the Dehn-fillings.
The isometry signature is always a (decorated) isomorphism signature, see
<a class="reference internal" href="#snappy.Manifold.triangulation_isosig" title="snappy.Manifold.triangulation_isosig"><code class="xref py py-meth docutils literal notranslate"><span class="pre">triangulation_isosig()</span></code></a>, and was introduced in
<a class="reference external" href="http://arxiv.org/abs/1502.00383">Goerner ‘16</a>.</p>
<p>Depending on <code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_orientation</span></code>, it is a complete invariant of
either the oriented (if orientable) or unoriented hyperbolic 3-manifold.
If <code class="xref py py-attr docutils literal notranslate"><span class="pre">of_link</span> <span class="pre">=</span> <span class="pre">True</span></code> is specified, the signature is decorated by the
unoriented peripheral curves (aka meridian and longitude, up to homotopy).
If the 3-manifold arises as a link complement, the decorated isometry
signature obtained with <code class="xref py py-attr docutils literal notranslate"><span class="pre">of_link</span> <span class="pre">=</span> <span class="pre">True</span></code> is a complete invariant of
the link.</p>
<p>The isometry signature is computed differently based on whether there
is at least one unfilled cusp.</p>
<p><strong>Cusped manifolds</strong></p>
<p>If there is at least one unfilled cusped, we are in the cusped case.</p>
<p>Here is an example of two links having isometric (hyperbolic) complements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;L5a1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;L7n2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">()</span>
<span class="go">&#39;eLPkbdcddhgggb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">()</span>
<span class="go">&#39;eLPkbdcddhgggb&#39;</span>
</pre></div>
</div>
<p>The complements do have opposite handedness though:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">ignore_orientation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;eLPkbdcddxvvcv&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">ignore_orientation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;eLPkbdcddhgggb&#39;</span>
</pre></div>
</div>
<p>We can show that the two links are distinct:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">of_link</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;eLPkbdcddhgggb_baCbbaCb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">of_link</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;eLPkbdcddhgggb_bBcBbaCb&#39;</span>
</pre></div>
</div>
<p>If we Dehn-fill some cusps, the method uses the filled triangulation.
Here, we Dehn-fill the Whitehead link to get the figure-eight knot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">of_link</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;cPcbbbiht_bacb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">of_link</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;cPcbbbiht_bacb&#39;</span>
</pre></div>
</div>
<p>In general, the isometry signature is the isomorphism signature (see
<a class="reference internal" href="#snappy.Manifold.triangulation_isosig" title="snappy.Manifold.triangulation_isosig"><code class="xref py py-meth docutils literal notranslate"><span class="pre">triangulation_isosig()</span></code></a>) of the
<a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation()</span></code></a> of the
<a class="reference internal" href="#snappy.Manifold.filled_triangulation" title="snappy.Manifold.filled_triangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filled_triangulation()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">ignore_cusp_ordering</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">ignore_curve_orientations</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;cPcbbbiht_bacb&#39;</span>
</pre></div>
</div>
<p><strong>Closed manifolds</strong></p>
<p>If all cusps are filled, we are in the closed case. In this case, the
isometry signature gives the resulting closed hyperbolic 3-manifold as
canonical surgery on a hyperbolic 1-cusped manifold (which is encoded by
its isometry signature). Only orientable manifolds are supported in the
closed case.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;v2000(1,3)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">()</span>
<span class="go">&#39;fLLQcacdedenbxxrr(-7,12)&#39;</span>
</pre></div>
</div>
<p>The following code illustrates how the isometry signature is computed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">length_spectrum_alt</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">[Length                                      Core curve  Word</span>
<span class="go"> 0.06491027903143 - 2.63765810995071*I       -           d,</span>
<span class="go"> 0.49405010583448 + 2.38451103485706*I       -           a]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill_word</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">ignore_cusp_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_curves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;fLLQcacdedenbxxrr(-7,12)&#39;</span>
</pre></div>
</div>
<p>Note that there is clearly a unique shortest geodesic in this example.
In general, the method first considers a canonical set of geodesics.
For each such geodesic, it computes a candidate signature as above. It
then picks a canonical signature among the candidates. Further details
can be found in an upcoming paper.</p>
<p><strong>Verified computations</strong></p>
<p>While the isometry signature is purely combinatorial, some intermediate
computations are numerical. Thus, if <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">False</span></code>,
floating-point issues can arise.</p>
<p>The method can be made <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified</span></a> by passing
<code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">=</span><span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m007(4,1)&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">isometry_signature</span><span class="p">(</span><span class="n">verified</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="s1">&#39;eLPkbcdddhggsj(3,1)&#39;</span>
</pre></div>
</div>
<p>This method always needs to compute at least one canonical retriangulation.
It can take the same arguments as <a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation()</span></code></a> and
passes them to <a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation()</span></code></a> when computing the
verified canonical retriangulation. If the manifold is closed, interval
arithmetic is used when finding and drilling the short geodesics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>of_link</strong> – Also encode the unoriented peripheral curves.
Note that it is not necessary for the manifold to be a link
complement to invoke this flag.
Only relevant in the cusped case.</p></li>
<li><p><strong>ignore_orientation</strong> – Do not encode the orientation of the 3-manifold.</p></li>
<li><p><strong>verified</strong> – Use <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computation</span></a>.</p></li>
<li><p><strong>interval_bits_precs</strong> – Passed to <a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation()</span></code></a> and (in the closed
case) also used when calling <a class="reference internal" href="#snappy.Manifold.length_spectrum_alt_gen" title="snappy.Manifold.length_spectrum_alt_gen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length_spectrum_alt_gen()</span></code></a> and
<a class="reference internal" href="#snappy.Manifold.drill_word" title="snappy.Manifold.drill_word"><code class="xref py py-meth docutils literal notranslate"><span class="pre">drill_word()</span></code></a> to find and drill the short geodesics.</p></li>
<li><p><strong>exact_bits_prec_and_degrees</strong> – Passed to <a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation()</span></code></a>.</p></li>
<li><p><strong>verbose</strong> – Print information about finding and drilling the short geodesics.
Also passed to <a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.isomorphisms_to">
<span class="sig-name descname"><span class="pre">isomorphisms_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="triangulation.html#snappy.Triangulation" title="snappy.Triangulation"><span class="pre">Triangulation</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">TriangulationHP</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Isometry</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#snappy.Manifold.isomorphisms_to" title="Link to this definition"></a></dt>
<dd><p>Returns a complete list of combinatorial isomorphisms between
the two triangulations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5^2_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5^2_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">([[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="go">0 -&gt; 1  1 -&gt; 0</span>
<span class="go">[ 1 0]  [-1 1]</span>
<span class="go">[-1 1]  [-3 2]</span>
<span class="go">Does not extend to link</span>
</pre></div>
</div>
<p>Each transformation between cusps is given by a matrix which
acts on the left.  That is, the two <em>columns</em> of the matrix
give the image of the meridian and longitude respectively.  In
the above example, the meridian of cusp 0 is sent to the
meridian of cusp 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.length_spectrum">
<span class="sig-name descname"><span class="pre">length_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_rigor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grouped</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_words</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.length_spectrum" title="Link to this definition"></a></dt>
<dd><p>Returns a list of geodesics (with multiplicities) of length
up to the specified cutoff value. (The default cutoff is 1.0.)</p>
<p>Here’s a quick example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m016&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">length_spectrum</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">include_words</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> 
<span class="go">mult  length                                  topology     parity word</span>
<span class="go">1     0.58460368501799 +  2.49537045556047*I  circle       +      a</span>
<span class="go">1     0.72978937305180 +  3.02669828218116*I  circle       +      Bc</span>
</pre></div>
</div>
<p>Access just the length:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">length</span> 
<span class="go">0.584603685017987 + 2.495370455560469*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.length_spectrum_alt">
<span class="sig-name descname"><span class="pre">length_spectrum_alt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_len</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">LengthSpectrumGeodesicInfo</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#snappy.Manifold.length_spectrum_alt" title="Link to this definition"></a></dt>
<dd><p>Returns a list of geodesics. How far this list goes can be specified
by either a cut-off length or a count. The method only supports
orientable manifolds. It is a convenience method for 
<a class="reference internal" href="#snappy.Manifold.length_spectrum_alt_gen" title="snappy.Manifold.length_spectrum_alt_gen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length_spectrum_alt_gen()</span></code></a>.
We refer the reader to
<a class="reference internal" href="#snappy.Manifold.length_spectrum_alt_gen" title="snappy.Manifold.length_spectrum_alt_gen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length_spectrum_alt_gen()</span></code></a>
for further details not covered here.</p>
<p><strong>Cut-off length</strong></p>
<p>Here is an example where a cut-off length for the geodesics is specified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m202(3,4)(3,4)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">length_spectrum_alt</span><span class="p">(</span><span class="n">max_len</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> 
<span class="go">[Length                                      Core curve  Word</span>
<span class="go"> 0.14820741547094 - 1.76955170166922*I       Cusp 1      bcDc,</span>
<span class="go"> 0.14820741547097 - 1.76955170166923*I       Cusp 0      aabcDabcB]</span>
</pre></div>
</div>
<p>It also supports <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified</span></a> computations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.length_spectrum_alt(max_len = 0.5, verified = True, bits_prec = 100) # doctest: +SKIP
[Length                                      Core curve  Word
 0.148207415470948?  - 1.76955170166924?  *I Cusp 0      aabcDabcB,
 0.14820741547094... - 1.76955170166923...*I Cusp 1      bcDc]
</pre></div>
</div>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified=True</span></code>, the returned list is guaranteed to include all
geodesics up to the given cut-off length and might include additional
geodesics.</p>
<p><strong>Count</strong></p>
<p>Here is an example where a count is specified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m202(3,4)(3,4)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">length_spectrum_alt</span><span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> 
<span class="go">[Length                                      Core curve  Word</span>
<span class="go"> 0.14820741547094 - 1.76955170166922*I       Cusp 1      bcDc,</span>
<span class="go"> 0.14820741547097 - 1.76955170166923*I       Cusp 0      aabcDabcB,</span>
<span class="go"> 0.79356651781096 + 2.65902431489655*I       -           aB,</span>
<span class="go"> 0.79356651781096 + 2.65902431489655*I       -           b]</span>
</pre></div>
</div>
<p>Note that the number of geodesics listed might be larger than the given
count. In particular, this happens when the same (real) length appears
multiple times. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified=True</span></code>, the returned list is guaranteed
to include the <code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code> shortest geodesics and might include additional
geodesics.</p>
<p><strong>Verified systole</strong></p>
<p>Even though, the first reported geodesic might not be the shortest, we
obtain an interval containing the systole as follows, also see
<a class="reference internal" href="#snappy.Manifold.length_spectrum_alt_gen" title="snappy.Manifold.length_spectrum_alt_gen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length_spectrum_alt_gen()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&quot;m004&quot;)
sage: M.length_spectrum_alt(count=1, verified=True, bits_prec=100)[0].length.real() # doctest: +NUMERIC21
1.0870701449957390997853?
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>count</strong> – Number of shortest geodesics to list. The actual result might
contain additional geodesics. Exactly one of <code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">max_len</span></code> has to be specified.</p></li>
<li><p><strong>max_len</strong> – Cut-off length for geodesics. The actual result includes all
geodesics up to the given length and might include additional
geodesics. Exactly one of <code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">max_len</span></code> has
to be specified.</p></li>
<li><p><strong>bits_prec</strong> – Precision used for the computation. Increase if computation did
not succeed.</p></li>
<li><p><strong>verified</strong> – Use <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computation</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of geodesics such that the (lower bound of) the real
length is non-decreasing.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.length_spectrum_alt_gen">
<span class="sig-name descname"><span class="pre">length_spectrum_alt_gen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">LengthSpectrumGeodesicInfo</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#snappy.Manifold.length_spectrum_alt_gen" title="Link to this definition"></a></dt>
<dd><p>Returns a generator for the geodesics sorted by real length. The method
only supports orientable manifolds.</p>
<p>Here is an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m202(3,4)(0,0)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spec</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">length_spectrum_alt_gen</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> 
<span class="go">Length                                      Core curve  Word</span>
<span class="go">0.14742465268512 - 1.78287093565202*I       Cusp 0      aabcDabcB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> 
<span class="go">0.81161414965958 + 2.72911699294426*I       -           b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> 
<span class="go">0.84163270359334 + 2.61245944742151*I       -           aB</span>
</pre></div>
</div>
<p>Note that the shortest geodesic in the above example happens to be the
core curve of the filled cusp (Cusp 0).</p>
<p>Access just the length or word:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">length</span> 
<span class="go">0.93461379591349 + 2.70060614107722*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">word</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
<p>The word is given with respect to the unsimplified fundamental group:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="n">simplify_presentation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">complex_length</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> 
<span class="go">0.93461379591349 + 2.70060614107722*I</span>
</pre></div>
</div>
<p>The method also supports higher precision:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m003(-3,1)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spec</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">length_spectrum_alt_gen</span><span class="p">(</span><span class="n">bits_prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">length</span> 
<span class="go">0.58460368501798696932015666264 + 2.4953704555604684110903962008*I</span>
</pre></div>
</div>
<p><strong>Performance</strong></p>
<p>This method uses a different algorithm than
<a class="reference internal" href="#snappy.Manifold.length_spectrum" title="snappy.Manifold.length_spectrum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length_spectrum</span></code></a>. In particular,
it does not compute the Dirichlet domain. It also allows for
<a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computations</span></a>.
It is implemented in python and thus
typically slower than <a class="reference internal" href="#snappy.Manifold.length_spectrum" title="snappy.Manifold.length_spectrum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">length_spectrum</span></code></a>.
But there are also some cases where it is significantly faster. In
particular, this applies to spun triangulations such as <code class="docutils literal notranslate"><span class="pre">m004(21,10)</span></code>.</p>
<p>Here is example where we can help the algorithm by guessing and drilling
and filling a short geodesic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;o9_00639&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Over an hour to compute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">high_precision</span><span class="p">()</span><span class="o">.</span><span class="n">length_spectrum</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> 
<span class="go">mult  length                                  topology     parity</span>
<span class="go">1     0.00150226276052 - 2.39996262244127*I   circle       +</span>
</pre></div>
</div>
<p>A couple of minutes to compute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spec</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">length_spectrum_alt_gen</span><span class="p">(</span><span class="n">bits_prec</span> <span class="o">=</span> <span class="mi">150</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>  
<span class="go">Length                                       Word          Core curve</span>
<span class="go">0.00150226276052 - 2.39996262244127*I        a             -</span>
</pre></div>
</div>
<p>After drilling and filling, less than a second to compute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill_word</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># N is now isometric to o9_00639 but as a surgery m125(0,0)(34,55)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spec</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">length_spectrum_alt_gen</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> 
<span class="go">Length                                      Core curve  Word</span>
<span class="go">0.00150226276073 - 2.39996262244128*I       Cusp 1      cDcDDcDcDDcDDcDcDDcDcDDcDDcDcDDcDD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> 
<span class="go">0.96218768626877</span>
</pre></div>
</div>
<p><strong>Verified computations</strong></p>
<p>The method also supports <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computations</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m019&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">length_spectrum_alt_gen</span><span class="p">(</span><span class="n">verified</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bits_prec</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">Length</span>                                      <span class="n">Core</span> <span class="n">curve</span>  <span class="n">Word</span>
<span class="mf">0.43153441294719</span><span class="o">...</span> <span class="o">+</span> <span class="mf">2.35105908147863</span><span class="o">...*</span><span class="n">I</span> <span class="o">-</span>           <span class="n">a</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="mf">0.88944299721255</span><span class="o">...</span> <span class="o">-</span> <span class="mf">2.94185904702273</span><span class="o">...*</span><span class="n">I</span> <span class="o">-</span>           <span class="n">bD</span>
</pre></div>
</div>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code> is passed, the algorithm guarantees that the lower
bound of the real length is (non-strictly) increasing. In particular, we know
that we have found all geodesics less than the following length:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="c1"># doctest: +NUMERIC12</span>
<span class="mf">0.94135129037387168886341739832</span>
</pre></div>
</div>
<p>To illustrate some pitfalls, here is an example of a potential a result
of the method:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Real length interval</p></th>
<th class="head"><p>Word</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[1.2,</span> <span class="pre">1.3]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">b</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[1.7,</span> <span class="pre">1.8]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[3.0,</span> <span class="pre">4.0]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">d</span></code></p></td>
</tr>
</tbody>
</table>
<p>Note that we cannot say whether geodesic <code class="docutils literal notranslate"><span class="pre">a</span></code> is actually the first,
second or third shortest geodesic or tied with <code class="docutils literal notranslate"><span class="pre">b</span></code> or <code class="docutils literal notranslate"><span class="pre">c</span></code>. Increasing
precision can change (representative words and) the order in which the
geodesics are emitted.</p>
<p>We can say that together <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> are the three shortest
geodesics. Furthermore, we can also say that the systole
of the manifold is in <code class="docutils literal notranslate"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code> even though <code class="docutils literal notranslate"><span class="pre">a</span></code> itself might not be
the shortest geodesic. The latter is true in general:</p>
<p><strong>Verified systole</strong></p>
<p>It is not necessarily true that the first geodesic returned
by the method is the shortest geodesic. Despite this, the interval for
the real length of the first geodesic always contains the systole of
the manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&quot;m004&quot;)
sage: spec = M.length_spectrum_alt_gen(verified=True)
sage: g = next(spec) # g might or might not be shortest geodesic
sage: systole = g.length.real() # But interval is large enough to contain systole
sage: systole # doctest: +NUMERIC6
1.08707015?
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bits_prec</strong> – Precision used for the computation. Increase if computation did
not succeed.</p></li>
<li><p><strong>verified</strong> – Use <a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified computation</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A generator to enumerate the geodesics such that the (lower bound
of the) real length is non-decreasing.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.link">
<span class="sig-name descname"><span class="pre">link</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.link" title="Link to this definition"></a></dt>
<dd><p>If the manifold is stored as a link complement in your
current session then it returns the number of components
and crossing of the link. To view and interact with the
link see <a class="reference internal" href="spherogram.html#spherogram.Link.view" title="spherogram.Link.view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spherogram.Link.view()</span></code></a>
and <a class="reference internal" href="triangulation.html#snappy.Triangulation.plink" title="snappy.Triangulation.plink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plink</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.name">
<span class="sig-name descname"><span class="pre">name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#snappy.Manifold.name" title="Link to this definition"></a></dt>
<dd><p>Return the name of the triangulation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;4_1&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.normal_boundary_slopes">
<span class="sig-name descname"><span class="pre">normal_boundary_slopes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'FXrays'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.normal_boundary_slopes" title="Link to this definition"></a></dt>
<dd><p>For a one-cusped manifold, returns all the nonempty boundary slopes of
spun normal surfaces.  Provided the triangulation supports a
genuine hyperbolic structure, then by <a class="reference external" href="http://arxiv.org/abs/math/0503027">Thurston and Walsh</a> any strict boundary slope
(the boundary of an essential surface which is not a fiber or
semifiber) must be listed here.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K3_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">()</span>
<span class="go">[(16, -1), (20, -1), (37, -2)]</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">subset</span></code> flag is set to <code class="docutils literal notranslate"><span class="pre">'kabaya'</span></code>, then it only
returns boundary slopes associated to vertex surfaces with a quad
in every tetrahedron; by Theorem 1.1. of
<a class="reference external" href="http://arxiv.org/abs/1102.4588">Dunfield and Garoufalidis ‘12</a>
these are all strict boundary slopes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m113&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">()</span>
<span class="go">[(1, 1), (1, 2), (2, -1), (2, 3), (8, 11)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">(</span><span class="s1">&#39;kabaya&#39;</span><span class="p">)</span>
<span class="go">[(8, 11)]</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">subset</span></code> flag is set to <code class="docutils literal notranslate"><span class="pre">'brasile'</span></code> then it returns
only the boundary slopes that are associated to vertex surfaces
giving isolated rays in the space of embedded normal surfaces.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">(</span><span class="s1">&#39;brasile&#39;</span><span class="p">)</span>
<span class="go">[(1, 2), (8, 11)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.normal_surfaces">
<span class="sig-name descname"><span class="pre">normal_surfaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'FXrays'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.normal_surfaces" title="Link to this definition"></a></dt>
<dd><p>All the vertex spun-normal surfaces in the current triangulation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">normal_surfaces</span><span class="p">()</span>    
<span class="go">[&lt;Surface 0: [0, 0] [1, 2] (4, 1)&gt;,</span>
<span class="go"> &lt;Surface 1: [0, 1] [1, 2] (4, -1)&gt;,</span>
<span class="go"> &lt;Surface 2: [1, 2] [2, 1] (-4, -1)&gt;,</span>
<span class="go"> &lt;Surface 3: [2, 2] [2, 1] (-4, 1)&gt;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.num_cusps">
<span class="sig-name descname"><span class="pre">num_cusps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cusp_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#snappy.Manifold.num_cusps" title="Link to this definition"></a></dt>
<dd><p>Return the total number of cusps.  By giving the optional argument
‘orientable’ or ‘nonorientable’ it will only count cusps of that type.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.num_tetrahedra">
<span class="sig-name descname"><span class="pre">num_tetrahedra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#snappy.Manifold.num_tetrahedra" title="Link to this definition"></a></dt>
<dd><p>Return the number of tetrahedra in the triangulation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.orientation_cover">
<span class="sig-name descname"><span class="pre">orientation_cover</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.orientation_cover" title="Link to this definition"></a></dt>
<dd><p>For a non-orientable Triangulation, returns the 2-fold cover which
is orientable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;x123&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">orientation_cover</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">())</span>
<span class="go">(False, True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span>
<span class="go">x123~(0,0)(0,0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span><span class="o">.</span><span class="n">cover_info</span><span class="p">()[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
<span class="go">&#39;cyclic&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.plink">
<span class="sig-name descname"><span class="pre">plink</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.plink" title="Link to this definition"></a></dt>
<dd><p>Brings up a link editor window if the manifold is stored
as a link complement in your current session.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;4_1&#39;</span><span class="p">)</span> <span class="c1"># stored as a triangulation with a link</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">link</span><span class="p">()</span>
<span class="go">&lt;Link: 1 comp; 4 cross&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span> <span class="c1"># stored as a triangulation without a link</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">link</span><span class="p">()</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No associated link known.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.polished_holonomy">
<span class="sig-name descname"><span class="pre">polished_holonomy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lift_to_SL2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_solution_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dec_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.polished_holonomy" title="Link to this definition"></a></dt>
<dd><p>Return the fundamental group of M equipped with a high-precision version of
the holonomy representation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">polished_holonomy</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
<span class="mf">1.5000000000000000000000000000</span> <span class="o">-</span> <span class="mf">0.86602540378443864676372317075</span><span class="o">*</span><span class="n">I</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">polished_holonomy</span><span class="p">(</span><span class="n">bits_prec</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="n">Complex</span> <span class="n">Field</span> <span class="k">with</span> <span class="mi">1000</span> <span class="n">bits</span> <span class="n">of</span> <span class="n">precision</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.ptolemy_generalized_obstruction_classes">
<span class="sig-name descname"><span class="pre">ptolemy_generalized_obstruction_classes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_generalized_obstruction_classes" title="Link to this definition"></a></dt>
<dd><p>Returns the obstruction classes needed to compute
PGL(N,C)-representations for any N, i.e., it returns a list with
a representative cocycle for each element in
H^2(M, boundary M; Z/N) / (Z/N)^* where (Z/N)^* are the units in Z/N.
The first element in the list always corresponds to the trivial
obstruction class.
The generalized ptolemy obstruction classes are thus a generalization
of the ptolemy obstruction classes that allow to find all
boundary-unipotent
PGL(N,C)-representations including those that do not lift to
boundary-unipotent SL(N,C)-representations for N odd or
SL(N,C)/{+1,-1}-representations for N even.</p>
<p>For example, 4_1 has three obstruction classes up to equivalence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>For 4_1, we only get three obstruction classes even though we have
H^2(M, boundary M; Z/4) = Z/4 because the two obstruction classes
1 in Z/4 and -1 in Z/4 are related by a unit and thus give
isomorphic Ptolemy varieties.</p>
<p>The primary use of an obstruction class sigma is to construct the
Ptolemy variety of sigma. This variety computes boundary-unipotent
PGL(N,C)-representations whose obstruction class to a
boundary-unipotent lift to SL(N,C) is sigma.</p>
<p>For example for 4_1, there are 2 obstruction classes for N = 3:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The Ptolemy variety parametrizing boundary-unipotent
SL(3,C)-representations of 4_1 is obtained by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>and the Ptolemy variety parametrizing boundary-unipotent
PSL(3,C)-representations of 4_1 that do not lift to
boundary-unipotent SL(3,C)-representations is obtained by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The cocycle representing the non-trivial obstruction class looks as
follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">PtolemyGeneralizedObstructionClass([2, 0, 0, 1])</span>
</pre></div>
</div>
<p>This means that the cocycle takes the value -1 in Z/3 on the first face
class and 1 on the fourth face class but zero on every other of the
four face classes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.ptolemy_obstruction_classes">
<span class="sig-name descname"><span class="pre">ptolemy_obstruction_classes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_obstruction_classes" title="Link to this definition"></a></dt>
<dd><p>Returns the obstruction classes needed to compute
pSL(N,C) = SL(N,C)/{+1,-1} representations for even N, i.e., it
returns a list with a representative cocycle for each class in
H^2(M, boundary M; Z/2). The first element in the list is always
representing the trivial obstruction class.</p>
<p>For example, 4_1 has two obstruction classes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_obstruction_classes</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The primary use of these obstruction classes is to construct
the Ptolemy variety as described in Definition 1.7 of
Stavros Garoufalidis, Dylan Thurston, Christian K. Zickert:
“The Complex Volume of SL(n,C)-Representations of 3-Manifolds”
(<a class="reference external" href="http://arxiv.org/abs/1111.2828">http://arxiv.org/abs/1111.2828</a>).</p>
<p>For example, to construct the Ptolemy variety for
PSL(2,C)-representations of 4_1 that do not lift to boundary-parabolic
SL(2,C)-representations, use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Or the following short-cut:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that this obstruction class only makes sense for even N:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">PtolemyObstructionClass only makes sense for even N, try PtolemyGeneralizedObstructionClass</span>
</pre></div>
</div>
<p>To obtain PGL(N,C)-representations for N &gt; 2, use the generalized
obstruction class:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The original obstruction class encodes a representing cocycle in Z/2 as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_obstruction_classes</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">PtolemyObstructionClass(s_0_0 + 1, s_1_0 - 1, s_2_0 - 1, s_3_0 + 1, s_0_0 - s_0_1, s_1_0 - s_3_1, s_2_0 - s_2_1, s_3_0 - s_1_1)</span>
</pre></div>
</div>
<p>This means that the cocycle to represent this obstruction class in Z/2
takes value 1 in Z/2 on face 0 of tetrahedra 0 (because s_0_0 = -1)
and value 0 in Z/2 on face 1 of tetrahedra 0 (because s_1_0 = +1).</p>
<p>Face 3 of tetrahedra 0 and face 1 of tetrahedra 1 are identified,
hence the cocycle takes the same value on those two faces (s_3_0 = s_1_1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.ptolemy_variety">
<span class="sig-name descname"><span class="pre">ptolemy_variety</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obstruction_class</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eliminate_fixed_ptolemys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_variety" title="Link to this definition"></a></dt>
<dd><p>Returns a Ptolemy variety as described in</p>
<ul class="simple">
<li><p>Stavros Garoufalidis, Dyland Thurston, Christian K. Zickert:
“The Complex Volume of SL(n,C)-Representations of 3-Manifolds”
(<a class="reference external" href="http://arxiv.org/abs/1111.2828">http://arxiv.org/abs/1111.2828</a>)</p></li>
<li><p>Stavros Garoufalidis, Matthias Goerner, Christian K. Zickert:
“Gluing Equations for PGL(n,C)-Representations of 3-Manifolds ”
(<a class="reference external" href="http://arxiv.org/abs/1207.6711">http://arxiv.org/abs/1207.6711</a>)</p></li>
</ul>
<p>The variety can be exported to magma or sage and solved there. The
solutions can be processed to compute invariants. The method can also
be used to automatically look up precomputed solutions from the
database at <a class="reference external" href="http://ptolemy.unhyperbolic.org/data">http://ptolemy.unhyperbolic.org/data</a> .</p>
<p>Example for m011 and PSL(2,C)-representations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;m011&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Obtain all Ptolemy varieties for PSL(2,C)-representations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two Ptolemy varieties for the two obstruction classes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Retrieve the solutions from the database</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">retrieve_solutions</span><span class="p">()</span> 
</pre></div>
</div>
<p>Compute the solutions using magma (default in SnapPy)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">(</span><span class="n">engine</span> <span class="o">=</span> <span class="s1">&#39;magma&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Compute the solutions using singular (default in sage)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">(</span><span class="n">engine</span> <span class="o">=</span> <span class="s1">&#39;sage&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Note that magma is significantly faster.</p>
<p>Compute all resulting complex volumes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span> <span class="o">=</span> <span class="n">sols</span><span class="o">.</span><span class="n">complex_volume_numerical</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span>  
<span class="go">[[[-4.29405713186238 E-16 + 0.725471193740844*I,</span>
<span class="go">   -0.942707362776931 + 0.459731436553693*I,</span>
<span class="go">   0.942707362776931 + 0.459731436553693*I]],</span>
<span class="go"> [[3.94159248086745 E-15 + 0.312682687518267*I,</span>
<span class="go">   4.64549527022581 E-15 + 0.680993020093457*I,</span>
<span class="go">   -2.78183391239608 - 0.496837853805869*I,</span>
<span class="go">   2.78183391239608 - 0.496837853805869*I]]]</span>
</pre></div>
</div>
<p>Show complex volumes as a non-nested list:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">[-4.29405713186238 E-16 + 0.725471193740844*I,</span>
<span class="go"> -0.942707362776931 + 0.459731436553693*I,</span>
<span class="go"> 0.942707362776931 + 0.459731436553693*I,</span>
<span class="go"> 3.94159248086745 E-15 + 0.312682687518267*I,</span>
<span class="go"> 4.64549527022581 E-15 + 0.680993020093457*I,</span>
<span class="go"> -2.78183391239608 - 0.496837853805869*I,</span>
<span class="go"> 2.78183391239608 - 0.496837853805869*I]</span>
</pre></div>
</div>
<p>For more examples, go to <a class="reference external" href="http://ptolemy.unhyperbolic.org/">http://ptolemy.unhyperbolic.org/</a></p>
<p>=== Optional Arguments ===</p>
<p>obstruction_class — class from Definition 1.7 of (1).
None for trivial class or a value returned from ptolemy_obstruction_classes.
Short cuts: obstruction_class = ‘all’ returns a list of Ptolemy varieties
for each obstruction. For easier iteration, can set obstruction_class to
an integer.</p>
<p>simplify — boolean to indicate whether to simplify the equations which
significantly reduces the number of variables.
Simplifying means that several identified Ptolemy coordinates x = y = z = …
are eliminated instead of adding relations x - y = 0, y - z = 0, …</p>
<p>eliminate_fixed_ptolemys — boolean to indicate whether to eliminate
the Ptolemy coordinates that are set to 1 for fixing the decoration.
Even though this simplifies the resulting representation, setting it to
True can cause magma to run longer when finding a Groebner basis.</p>
<p>=== Examples for 4_1 ===</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the varieties for all obstruction classes at once (use
help(varieties[0]) for more information):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">varieties</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Print the variety as an ideal (sage object) for the non-trivial class:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">varieties</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ideal</span>    
<span class="go">Ideal (-c_0011_0^2 + c_0011_0*c_0101_0 + c_0101_0^2, -c_0011_0^2 - c_0011_0*c_0101_0 + c_0101_0^2, c_0011_0 - 1) of Multivariate Polynomial Ring in c_0011_0, c_0101_0 over Rational Field</span>
</pre></div>
</div>
<p>Print the equations of the variety for the non-trivial class:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">varieties</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">equations</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>          
<span class="go">     - c_0011_0 * c_0101_0 + c_0011_0^2 + c_0101_0^2</span>
<span class="go">     c_0011_0 * c_0101_0 - c_0011_0^2 - c_0101_0^2</span>
<span class="go">     - 1 + c_0011_0</span>
</pre></div>
</div>
<p>Generate a magma file to compute Primary Decomposition for N = 3:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">to_magma</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;ring and ideal&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>     
<span class="go">R&lt;c_0012_0, c_0012_1, c_0102_0, c_0111_0, c_0201_0, c_1011_0, c_1011_1, c_1101_0&gt; := PolynomialRing(RationalField(), 8, &quot;grevlex&quot;);</span>
<span class="go">MyIdeal := ideal&lt;R |</span>
<span class="go">          c_0012_0 * c_1101_0 + c_0102_0 * c_0111_0 - c_0102_0 * c_1011_0,</span>
<span class="go">    ...</span>
</pre></div>
</div>
<p>=== If you have a magma installation ===</p>
<p>Call p.compute_solutions() to automatically call magma on the above output
and produce exact solutions!!!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">()</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c1"># magma failed, use precomputed_solutions</span>
<span class="gp">... </span>    <span class="n">sols</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p>Check solutions against manifold
&gt;&gt;&gt; if sols:
…     dummy = sols.check_against_manifold()</p>
<p>=== If you do not have a magma installation ===</p>
<p>Load a precomputed example from magma which is provided with the package:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">snappy.ptolemy.processMagmaFile</span> <span class="kn">import</span> <span class="n">_magma_output_for_4_1__sl3</span><span class="p">,</span> <span class="n">solutions_from_magma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">_magma_output_for_4_1__sl3</span><span class="p">)</span>      

<span class="go">==TRIANGULATION=BEGINS==</span>
<span class="go">% Triangulation</span>
<span class="go">4_1</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Parse the file and produce solutions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">solutions_from_magma</span><span class="p">(</span><span class="n">_magma_output_for_4_1__sl3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dummy</span> <span class="o">=</span> <span class="n">sols</span><span class="o">.</span><span class="n">check_against_manifold</span><span class="p">()</span>
</pre></div>
</div>
<p>=== Continue here whether you have or do not have magma ===</p>
<p>Pick the first solution of the three different solutions (up to Galois
conjugates):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solution</span> <span class="o">=</span> <span class="n">sols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Read the exact value for c_1020_0 (help(solution) for more information
on how to compute cross ratios, volumes and other invariants):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;c_1020_0&#39;</span><span class="p">]</span>
<span class="go">Mod(-1/2*x - 3/2, x^2 + 3*x + 4)</span>
</pre></div>
</div>
<p>Example of simplified vs non-simplified variety for N = 4:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">simplified</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">full</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">simplify</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">simplified</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">full</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
<span class="go">(21, 63)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">simplified</span><span class="o">.</span><span class="n">equations</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">full</span><span class="o">.</span><span class="n">equations</span><span class="p">)</span>
<span class="go">(24, 72)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.randomize">
<span class="sig-name descname"><span class="pre">randomize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blowup_multiple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passes_at_fours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.randomize" title="Link to this definition"></a></dt>
<dd><p>Perform random Pachner moves on the underlying triangulation,
including some initial 3 -&gt; 2 moves that increase the number of
tetrahedra by blowup_multiple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;Braid:[1,2,-3,-3,1,2]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.reverse_orientation">
<span class="sig-name descname"><span class="pre">reverse_orientation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#snappy.Manifold.reverse_orientation" title="Link to this definition"></a></dt>
<dd><p>Reverses the orientation of the Triangulation, presuming that
it is orientable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">reverse_orientation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">cs</span> <span class="o">+</span> <span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">())</span> 
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.save" title="Link to this definition"></a></dt>
<dd><p>Save the triangulation as a SnapPea triangulation file.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;fig-eight.tri&#39;</span><span class="p">)</span>     
</pre></div>
</div>
<p>To retrieve a SnapPea triangulation from the saved file
you can do the following. The first command creates a cusped
manifold M. The second one creates the filled manifold M1
with Dehn coefficients (2,3).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;fig-eight.tri&#39;</span><span class="p">)</span>   
<span class="gp">&gt;&gt;&gt; </span><span class="n">M1</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;fig-eight.tri(2,3)&#39;</span><span class="p">)</span>   
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.set_name">
<span class="sig-name descname"><span class="pre">set_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#snappy.Manifold.set_name" title="Link to this definition"></a></dt>
<dd><p>Give the triangulation a new name.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s1">&#39;figure-eight-comp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">figure-eight-comp(0,0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.set_peripheral_curves">
<span class="sig-name descname"><span class="pre">set_peripheral_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peripheral_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which_cusp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_peripheral_curves" title="Link to this definition"></a></dt>
<dd><p>Each cusp has a preferred marking. In the case of a torus
cusp, this is pair of essential simple curves meeting in one
point; equivalently, a basis of the first homology of the
boundary torus. These curves are called the meridian and the
longitude.</p>
<p>This method changes these markings in various ways.  In many
cases, if the flag return_matrices is True then it returns
a list of change-of-basis matrices is returned, one per
cusp, which will restore the original markings if passed
as peripheral_data.</p>
<ul>
<li><p>Make the shortest curves the meridians, and the second
shortest curves the longitudes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> 
<span class="go">[-2.49024467 + 2.97944707*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cob</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="s1">&#39;shortest&#39;</span><span class="p">,</span> <span class="n">return_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> 
<span class="go">[-0.49024467 + 2.97944707*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cob</span>
<span class="go">[[[1, 0], [-2, 1]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="n">cob</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> 
<span class="go">[-2.49024467 + 2.97944707*I]</span>
</pre></div>
</div>
<p>You can also make just the meridians as short as
possible while fixing the longitudes via the option
‘shortest_meridians’, and conversely with
‘shortest_longitudes’.</p>
</li>
<li><p>If cusps are Dehn filled, make those curves meridians.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125(0,0)(2,5)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="s1">&#39;fillings&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">m125(0,0)(1,0)</span>
</pre></div>
</div>
</li>
<li><p>Change the basis of a particular cusp, say the first one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">]</span> <span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here (1,2) is the new meridian written in the old basis, and
(1,3) the new longitude.</p>
</li>
<li><p>Change the basis of all the cusps at once</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_curves</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>  <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="n">new_curves</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">m125(0,0)(-1,-2)</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.set_target_holonomy">
<span class="sig-name descname"><span class="pre">set_target_holonomy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which_cusp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_target_holonomy" title="Link to this definition"></a></dt>
<dd><p>Computes a geometric structure in which the Dehn filling curve
on the specified cusp has holonomy equal to the target value.
The holonomies of Dehn filling curves on other cusps are left
unchanged.  If the ‘recompute’ flag is False, the Dehn filling
equations are modified, but not solved.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.set_tetrahedra_shapes">
<span class="sig-name descname"><span class="pre">set_tetrahedra_shapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filled_shapes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete_shapes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_tetrahedra_shapes" title="Link to this definition"></a></dt>
<dd><p>Replaces the tetrahedron shapes with those in the given lists,
and sets the Dehn filling coefficients as specified by the
fillings argument.  The shapes will get double precision
values; polishing will be needed for high precision shapes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.short_slopes">
<span class="sig-name descname"><span class="pre">short_slopes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">policy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'unbiased'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'maximal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_cusps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.short_slopes" title="Link to this definition"></a></dt>
<dd><p>Returns a list of short slopes (for Dehn-fillings) for each cusp.</p>
<p>That is, the method uses <a class="reference internal" href="#snappy.Manifold.cusp_areas" title="snappy.Manifold.cusp_areas"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cusp_areas()</span></code></a> to find
(maximal) embedded and disjoint cusp neighborhoods. It uses the boundaries
of these cusp neighborhoods to measure the length of a peripheral curve.
For each cusp, it determines all simple peripheral curves shorter than
the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">length</span></code> (which defaults to 6). The result is a list
of the corresponding slopes for each cusp:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;otet20_00022&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">()</span>
<span class="go">[[(1, 0), (-1, 1), (0, 1)], [(1, 0)]]</span>
</pre></div>
</div>
<p>It takes the same arguments as <a class="reference internal" href="#snappy.Manifold.cusp_areas" title="snappy.Manifold.cusp_areas"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cusp_areas()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">(</span><span class="n">policy</span> <span class="o">=</span> <span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
<span class="go">[[(1, 0)], [(1, 0)]]</span>
</pre></div>
</div>
<p>The ten exceptional slopes of the figure-eight knot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">()</span>
<span class="go">[[(1, 0), (-4, 1), (-3, 1), (-2, 1), (-1, 1), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1)]]</span>
</pre></div>
</div>
<p>Two more slopes appear when increasing length to <span class="math notranslate nohighlight">\(2\pi\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">(</span><span class="n">length</span> <span class="o">=</span> <span class="mf">6.283185307179586</span><span class="p">)</span>
<span class="go">[[(1, 0), (-5, 1), (-4, 1), (-3, 1), (-2, 1), (-1, 1), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]]</span>
</pre></div>
</div>
<p><strong>Verified computation</strong></p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">False</span></code>, floating-point issues can arise resulting in
incorrect values. The method can be made
<a class="reference internal" href="verify.html#verify-primer"><span class="std std-ref">verified</span></a> by passing <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">(</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]]</span>
</pre></div>
</div>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>, the result is guaranteed to contain all short
slopes and might contain additional slopes (with lengths slightly longer
than the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">length</span></code> but this could not be proven using the
interval estimates).</p>
<p>The given <code class="xref py py-attr docutils literal notranslate"><span class="pre">length</span></code> is cast to a SageMath <code class="docutils literal notranslate"><span class="pre">RealIntervalField</span></code> of the
given precision if <code class="xref py py-attr docutils literal notranslate"><span class="pre">verified</span> <span class="pre">=</span> <span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">short_slopes</span><span class="p">(</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">,</span> <span class="n">verified</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">bits_prec</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="p">[[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.simplify">
<span class="sig-name descname"><span class="pre">simplify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">passes_at_fours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.simplify" title="Link to this definition"></a></dt>
<dd><p>Try to simplify the triangulation by doing Pachner moves.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;12n123&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
</pre></div>
</div>
<p>It does four kinds of moves that reduce the number of
tetrahedra:</p>
<ul class="simple">
<li><p>3 -&gt; 2 and 2 -&gt; 0 Pacher moves, which eliminate one or two
tetrahedra respectively.</p></li>
<li><p>On suitable valence-1 edges, does a 2 -&gt; 3 and then 2 -&gt; 0 move,
which removes a tetrahedron and creates a new valence-1 edge.</p></li>
<li><p>When a 2-simplex has two edges of valence-4 giving rise to the
suspension of a pentagon, replace these 6 tetrahedra with a
single edge of valence 5.</p></li>
</ul>
<p>It also does random 4 -&gt; 4 moves in hopes of setting up a
simplfication.  The argument passes_at_fours is the number of
times it goes through the valence-4 edges without progress
before giving up.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.slice_obstruction_HKL">
<span class="sig-name descname"><span class="pre">slice_obstruction_HKL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">primes_spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_in_S3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.slice_obstruction_HKL" title="Link to this definition"></a></dt>
<dd><p>For the exterior of a knot in S^3, searches for a topological
slicing obstruction from:</p>
<p>Herald, Kirk, Livingston, Math Zeit., 2010
<a class="reference external" href="https://dx.doi.org/10.1007/s00209-009-0548-1">https://dx.doi.org/10.1007/s00209-009-0548-1</a>
<a class="reference external" href="https://arxiv.org/abs/0804.1355">https://arxiv.org/abs/0804.1355</a></p>
<p>The test looks at the cyclic branched covers of the knot of prime
order p and the F_q homology thereof where q is an odd prime. The
range of such (p, q) pairs searched is given by primes_spec as a
list of (p_max, [q_min, q_max]).  It returns the pair (p, q) of
the first nonzero obstruction found (in which case K is not
slice), and otherwise returns None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K12n813&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">spec</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">]),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">])]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">slice_obstruction_HKL</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
   <span class="n">Looking</span> <span class="n">at</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">...</span>
   <span class="n">Looking</span> <span class="n">at</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">...</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also specify the p to examine by a range [p_min, p_max] or
the q by just q_max:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">spec</span> <span class="o">=</span> <span class="p">[([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="mi">10</span><span class="p">)]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">slice_obstruction_HKL</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
   <span class="n">Looking</span> <span class="n">at</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">...</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>If primes_spec is just a pair (p, q) then only that obstruction is
checked:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">slice_obstruction_HKL</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">slice_obstruction_HKL</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>Technical note: As implemented, can only get an obstruction when
the decomposition of H_1(cover; F_q) into irreducible Z/pZ-modules
has no repeat factors.  The method of [HKL] can be used more
broadly, but other cases requires computing many more twisted
Alexander polynomials.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.solution_type">
<span class="sig-name descname"><span class="pre">solution_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.solution_type" title="Link to this definition"></a></dt>
<dd><p>Returns the type of the current solution to the gluing
equations, basically a summary of how degenerate the solution
is.  If the flag enum=True is set, then an integer value is
returned. The possible answers are:</p>
<ul class="simple">
<li><p>0: ‘not attempted’</p></li>
<li><p>1: ‘all tetrahedra positively oriented’ aka ‘geometric_solution’
Should correspond to a genuine hyperbolic structure.</p></li>
<li><p>2: ‘contains negatively oriented tetrahedra’ aka ‘nongeometric_solution’
Probably corresponds to a hyperbolic structure but some
simplices have reversed orientations.</p></li>
<li><p>3: ‘contains flat tetrahedra’ All tetrahedra have shape in R - {0, 1}.</p></li>
<li><p>4: ‘contains degenerate tetrahedra’ Some shapes are close to
{0,1, or infinity}.</p></li>
<li><p>5: ‘unrecognized solution type’</p></li>
<li><p>6: ‘no solution found’</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m007&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;all tetrahedra positively oriented&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;contains negatively oriented tetrahedra&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;contains degenerate tetrahedra&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">which_surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.split" title="Link to this definition"></a></dt>
<dd><p>Split the manifold open along a surface of positive characteristic found
by the method “splitting_surfaces”.  Returns a list of the pieces, with any
sphere boundary components filled in.</p>
<p>Here’s an example of a Whitehead double on the trefoil.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K14n26039&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Orientable two-sided with euler = 0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="n">pieces</span>
<span class="go">[K14n26039.a(0,0)(0,0), K14n26039.b(0,0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> 
<span class="go">3.66386238</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span><span class="o">.</span><span class="n">relators</span><span class="p">()</span>
<span class="go">[&#39;aabbb&#39;]</span>
</pre></div>
</div>
<p>You can also specify a surface by its index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L10n111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span> 
<span class="go">5.33348957</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.splitting_surfaces">
<span class="sig-name descname"><span class="pre">splitting_surfaces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.splitting_surfaces" title="Link to this definition"></a></dt>
<dd><p>Searches for connected closed normal surfaces of nonnegative Euler
characteristic.  If spheres or projective planes are found, then
tori and Klein bottles aren’t reported.  There is no guarantee
that all such normal surfaces will be found nor that any given
surface is incompressible.  The search is confined to surfaces
whose quads are in the tetrahedra that have degenerate shapes.</p>
<p>You can split the manifold open along one of these surfaces
using the method “split”.</p>
<p>A connect sum of two trefoils:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M1</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;DT: fafBCAEFD&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">M1</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
<p>First satellite knot in the table.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M2</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;K13n4587&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M2</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">()</span>
<span class="go">[Orientable two-sided with euler = 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.symmetric_triangulation">
<span class="sig-name descname"><span class="pre">symmetric_triangulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.symmetric_triangulation" title="Link to this definition"></a></dt>
<dd><p>Returns a Dehn filling description of the manifold realizing
the symmetry group.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m003(-3,1)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">symmetry_group</span><span class="p">()</span>
<span class="go">D6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">symmetric_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">m003(1,0)(1,0)(1,0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">symmetry_group</span><span class="p">(</span><span class="n">of_link</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">D6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.symmetry_group">
<span class="sig-name descname"><span class="pre">symmetry_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">of_link</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="additional_classes.html#snappy.SymmetryGroup" title="SnapPy.SymmetryGroup"><span class="pre">SymmetryGroup</span></a></span></span><a class="headerlink" href="#snappy.Manifold.symmetry_group" title="Link to this definition"></a></dt>
<dd><p>Returns the symmetry group of the Manifold.
If the flag “of_link” is set, then it only returns symmetries
that preserves the meridians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.symplectic_basis">
<span class="sig-name descname"><span class="pre">symplectic_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verify</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.symplectic_basis" title="Link to this definition"></a></dt>
<dd><p>Extend the Neumann-Zagier matrix to one which is symplectic
(up to factors of 2) using oscillating curves, see
<a class="reference external" href="https://arxiv.org/abs/2208.06969">Mathews and Purcell ‘22</a>.
Only accepts triangulations with 1 cusp.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">symplectic_basis</span><span class="p">()</span>
<span class="go">[-1  0 -1 -1]</span>
<span class="go">[ 2  0 -2  0]</span>
<span class="go">[-2 -1 -2 -1]</span>
<span class="go">[ 0 -1 -2 -1]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>verify</strong> – Explicitly test if the resulting matrix is symplectic.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.tetrahedra_field_gens">
<span class="sig-name descname"><span class="pre">tetrahedra_field_gens</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.tetrahedra_field_gens" title="Link to this definition"></a></dt>
<dd><p>The shapes of the tetrahedra as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&#39;m015&#39;)
sage: tets = M.tetrahedra_field_gens()
sage: tets.find_field(100, 10, optimize=True)    # doctest: +NORMALIZE_WHITESPACE +NUMERIC9
(Number Field in z with defining polynomial x^3 - x - 1
 with z = -0.6623589786223730? - 0.5622795120623013?*I,
&lt;ApproxAN: -0.662358978622 - 0.562279512062*I&gt;, [-z, -z, -z])
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.tetrahedra_shapes">
<span class="sig-name descname"><span class="pre">tetrahedra_shapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">part</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dec_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intervals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.tetrahedra_shapes" title="Link to this definition"></a></dt>
<dd><p>Gives the shapes of the tetrahedra in the current solution to
the gluing equations.  Returns a list containing one info object
for each tetrahedron.  The keys are:</p>
<ul class="simple">
<li><p>rect : the shape of the tetrahedron, as a point in the
complex plane.</p></li>
<li><p>log : the log of the shape</p></li>
<li><p>accuracies: a list of the approximate accuracies of the
shapes, in order (rect re, rect im, log re, log im)</p></li>
</ul>
<p>If the optional variable ‘part’ is set to one of the above,
then the function returns only that component of the data.</p>
<p>If the flag ‘fixed_alignment’ is set to False, then the edges
used to report the shape parameters are chosen so as to
normalize the triangle.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">tetrahedra_shapes</span><span class="p">(</span><span class="n">part</span><span class="o">=</span><span class="s1">&#39;rect&#39;</span><span class="p">)</span> 
<span class="go">[0.66235898 + 0.56227951*I, 0.66235898 + 0.56227951*I, 0.66235898 + 0.56227951*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">tetrahedra_shapes</span><span class="p">()</span> 
<span class="go">[{&#39;accuracies&#39;: (11, 11, 12, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I},</span>
<span class="go"> {&#39;accuracies&#39;: (11, 11, 11, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I},</span>
<span class="go"> {&#39;accuracies&#39;: (11, 11, 11, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.trace_field_gens">
<span class="sig-name descname"><span class="pre">trace_field_gens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.trace_field_gens" title="Link to this definition"></a></dt>
<dd><p>The generators of the trace field as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m125&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">traces</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">trace_field_gens</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">traces</span><span class="o">.</span><span class="n">find_field</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
<span class="p">(</span><span class="n">Number</span> <span class="n">Field</span> <span class="ow">in</span> <span class="n">z</span> <span class="k">with</span> <span class="n">defining</span> <span class="n">polynomial</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
 <span class="k">with</span> <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">I</span><span class="p">,</span>
<span class="o">&lt;</span><span class="n">ApproxAN</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">I</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">[</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.triangulation_isosig">
<span class="sig-name descname"><span class="pre">triangulation_isosig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">decorated</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_cusp_ordering</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_curves</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_curve_orientations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_filling_orientations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#snappy.Manifold.triangulation_isosig" title="Link to this definition"></a></dt>
<dd><p>Returns the “(decorated) isomorphism signature”, a compact text
representation of the triangulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">()</span>
<span class="go">&#39;cPcbbbiht_BaCB&#39;</span>
</pre></div>
</div>
<p>This string can be used later to recreate an isomorphic triangulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">U</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;cPcbbbiht_BaCB&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">==</span> <span class="n">U</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The isomorphism signature is also used to compute the
<a class="reference internal" href="#snappy.Manifold.isometry_signature" title="snappy.Manifold.isometry_signature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isometry_signature</span></code></a>.
It comes in two flavors controlled by the <code class="xref py py-attr docutils literal notranslate"><span class="pre">decorated</span></code> flag.</p>
<p><strong>Undecorated isomorphism signature</strong></p>
<p>The undecorated isomorphism signature is a complete invariant of the
(oriented) triangulation up to combinatorial isomorphism:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;dLQbcccdero&#39;</span>
</pre></div>
</div>
<p>It was introduced in
<a class="reference external" href="http://arxiv.org/abs/1110.6080">Burton ‘11</a>. It canonizes and
generalizes the ealier dehydration string by
<a class="reference external" href="https://doi.org/10.1090/S0025-5718-99-01036-4">Callahan, Hildebrand and Weeks ‘99</a>.
The undecorated isomorphism signature can also be given to
<a class="reference external" href="https://regina-normal.github.io/">Regina</a>’s
<code class="docutils literal notranslate"><span class="pre">Triangulation3.fromIsoSig</span></code>.</p>
<p>By default, the orientation (if orientable) is ignored. More
precisely, it computes the string for both orientations (if orientable)
and uses the lexicographically smaller string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;dLQbcccdero&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">reverse_orientation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;dLQbcccdero&#39;</span>
</pre></div>
</div>
<p>When specifying <code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_orientation</span> <span class="pre">=</span> <span class="pre">False</span></code>, the result
encodes the orientation (if orientable). Now the result is
different if we change the orientation of a chiral triangulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_orientation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;dLQbcccdero&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">reverse_orientation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_orientation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;dLQbccceekg&#39;</span>
</pre></div>
</div>
<p><strong>Decorated isomorphism signature (default)</strong></p>
<p>SnapPy can decorate the isomorphism signature to include the following
peripheral information in a canonical way (that is invariant under
the action by combinatorial isomorphisms of the triangulation):</p>
<ol class="arabic simple">
<li><p>Indexing of the cusps (that is, ideal vertices).</p>
<ul class="simple">
<li><p>Included by default.
Can be suppressed with <code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_cusp_ordering</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p></li>
</ul>
</li>
<li><p>Peripheral curves (aka meridian and longitude, up to homotopy).</p>
<ul class="simple">
<li><p>Included by default.
Can be suppressed with <code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_curves</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p></li>
<li><p>By default, the decoration encodes the oriented peripheral curves.
By specifying <code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_curve_orientations</span> <span class="pre">=</span> <span class="pre">True</span></code>, it encodes
the unoriented peripheral curves instead.</p></li>
</ul>
</li>
<li><p>Dehn-fillings (if present).</p>
<ul class="simple">
<li><p>By default, the decoration encodes the oriented Dehn-fillings.
That is, we also encodes the orientation of the peripheral curve
that is used for the Dehn-filling (this explanation only
works if the coefficients are integral).
By specifying <code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_filling_orientations</span> <span class="pre">=</span> <span class="pre">True</span></code>, the
decoration encodes the unoriented Dehn-fillings.
That is, it normalizes the Dehn-filling coefficients by picking
a canonical pair among <span class="math notranslate nohighlight">\((m,l)\)</span> and <span class="math notranslate nohighlight">\((-m,-l)\)</span>.</p></li>
</ul>
</li>
</ol>
<p>Details of the encoding are explained in the
<a class="reference external" href="https://github.com/3-manifolds/SnapPy/blob/master/python/decorated_isosig.py">SnapPy source code</a>.</p>
<p><strong>Example</strong></p>
<p>Let us consider the links <span class="math notranslate nohighlight">\(9^2_{34}\)</span> and <code class="docutils literal notranslate"><span class="pre">L9a21</span></code>. Note that we use
<a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation</span></code></a>
to make the following examples say something intrinsic about the
hyperbolic manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">snappy</span> <span class="kn">import</span> <span class="n">Manifold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;9^2_34&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;L9a21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_retriangulation</span><span class="p">()</span>
</pre></div>
</div>
<p>The decorated isosig recovers the entire peripheral information faithfully
(including orientation, see below):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">()</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo_baBabbbBbC&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo_baBabbbBbC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="go">[0 -&gt; 0  1 -&gt; 1</span>
<span class="go">[1 0]   [1 0]</span>
<span class="go">[0 1]   [0 1]</span>
<span class="go">Extends to link]</span>
</pre></div>
</div>
<p>The two links have isometric complements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo&#39;</span>
</pre></div>
</div>
<p>However, the complements have different handedness:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">ignore_orientation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;oLLzLPwzQQccdeghjiiklmnmnnuvuvvavovvffffo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">decorated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">ignore_orientation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo&#39;</span>
</pre></div>
</div>
<p>Also, the cusps/components of the link are indexed differently:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">ignore_curves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo_ba&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">ignore_curves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo_ab&#39;</span>
</pre></div>
</div>
<p>Ignoring the indexing, we also see that the oriented merdians and
longitudes do not match:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">ignore_cusp_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo_bBbCBabb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">ignore_cusp_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo_BbbCbabb&#39;</span>
</pre></div>
</div>
<p>However, they are the same links (ignoring indexing and orientation):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">ignore_cusp_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_curve_orientations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo_bBBcbabb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span><span class="n">ignore_cusp_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_curve_orientations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo_bBBcbabb&#39;</span>
</pre></div>
</div>
<p>Let us create two surgery presentations from the links (note that we
fill after
<a class="reference internal" href="#snappy.Manifold.canonical_retriangulation" title="snappy.Manifold.canonical_retriangulation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_retriangulation</span></code></a>
since it rejects Dehn-fillings):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>They are equivalent surgery presentations (of the same manifold):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">ignore_cusp_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">ignore_curves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">ignore_filling_orientations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo(0,0)(1,5)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">triangulation_isosig</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">ignore_cusp_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">ignore_curves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">ignore_filling_orientations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;oLLvzQLLQQccdhifihnlmkmlnnpvuvbvouggbggoo(0,0)(1,5)&#39;</span>
</pre></div>
</div>
<p><strong>Orientation</strong></p>
<p>Note that <code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_orientation=True</span></code> only applies to the undecorated
part of the isomorphism signature. The decoration can still capture the
the orientation.
More, precisely, the result of <a class="reference internal" href="#snappy.Manifold.triangulation_isosig" title="snappy.Manifold.triangulation_isosig"><code class="xref py py-meth docutils literal notranslate"><span class="pre">triangulation_isosig()</span></code></a> depends on
the orientation (if the triangulation is orientable and chiral) if any
of the following is true:</p>
<ol class="arabic simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_orientation</span> <span class="pre">=</span> <span class="pre">False</span></code>.</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">decorated</span> <span class="pre">=</span> <span class="pre">True</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_curves</span> <span class="pre">=</span> <span class="pre">False</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_filling_orientations</span> <span class="pre">=</span> <span class="pre">False</span></code>.</p></li>
</ol>
<p>In these cases, re-constructing a triangulation from the isomorphism
signature yields a triangulation with the same handedness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>decorated</strong> – Include peripheral information such as indexing of the cusps,
(oriented or unoriented) peripheral curves and
(oriented or unoriented) Dehn-fillings.</p></li>
<li><p><strong>ignore_cusp_ordering</strong> – Do not encode the indexing of the cusps.
Only relevant if <code class="xref py py-attr docutils literal notranslate"><span class="pre">decorated</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p></li>
<li><p><strong>ignore_curves</strong> – Do not encode the peripheral curves.
Only relevant if <code class="xref py py-attr docutils literal notranslate"><span class="pre">decorated</span> <span class="pre">=</span> <span class="pre">True</span></code>.
This is new in SnapPy version 3.2.
If <code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_curves</span> <span class="pre">=</span> <span class="pre">True</span></code>, the result of this method cannot
be given to prior versions.</p></li>
<li><p><strong>ignore_curve_orientations</strong> – Do not encode the orientations of the peripheral curves.
Only relevant if <code class="xref py py-attr docutils literal notranslate"><span class="pre">decorated</span> <span class="pre">=</span> <span class="pre">True</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">ignore_curves</span> <span class="pre">=</span> <span class="pre">False</span></code>.</p></li>
<li><p><strong>ignore_filling_orientations</strong> – Do not encode the orientations of the Dehn-fillings.
Only relevant if <code class="xref py py-attr docutils literal notranslate"><span class="pre">decorated</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p></li>
<li><p><strong>ignore_orientation</strong> – Do not encode the orientation of the triangulation in the
undecorated part of the triangulation isosig.
See above section about orientation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.use_field_conversion">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">use_field_conversion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.use_field_conversion" title="Link to this definition"></a></dt>
<dd><p>A class method for specifying a numerical conversion function.
This method is deprecated: SnapPy will automatically use
SageMath number types or its own SnapPy number type depending on
whether SageMath is available or not.</p>
<p>SnapPy includes its own number type, snappy.Number, which can
represent floating point real or complex numbers of varying
precision.  (In fact, Number is a wrapper for a pari number of
type ‘t_INT’, ‘t_FRAC’, ‘t_REAL’ or ‘t_COMPLEX’, and the pari
gen can be extracted as an attribute: x.gen .)  Methods of
SnapPy objects which return numerical values will first compute
the value as a Number, and then optionally convert the Number
to a different numerical type which can be specified by calling
this class method.</p>
<p>By default SnapPy returns Numbers when loaded into python, and
elements of a Sage RealField or ComplexField when loaded into
Sage.  These will be 64 bit numbers for ordinary Manifolds and
212 bit numbers for high precision manifolds.</p>
<p>The func argument should be a function which accepts a number and
returns a numerical type of your choosing.  Alternatively, the
strings ‘sage’ or ‘snappy’ can be passed as arguments to select
either of the two default behaviors.</p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">R</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;RealField&#39;</span><span class="p">)</span>
<span class="kc">True</span>
<span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">snappy.number</span> <span class="kn">import</span> <span class="n">SnapPyNumbers</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Manifold</span><span class="o">.</span><span class="n">use_field_conversion</span><span class="p">(</span><span class="s1">&#39;snappy&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">R</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">SnapPyNumbers</span><span class="p">)</span>
<span class="kc">True</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Manifold</span><span class="o">.</span><span class="n">use_field_conversion</span><span class="p">(</span><span class="s1">&#39;sage&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">R</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;RealField&#39;</span><span class="p">)</span>
<span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.verify_hyperbolicity">
<span class="sig-name descname"><span class="pre">verify_hyperbolicity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holonomy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fundamental_group_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lift_to_SL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.verify_hyperbolicity" title="Link to this definition"></a></dt>
<dd><p>Given an orientable SnapPy Manifold, verifies its hyperbolicity.</p>
<p>Similar to HIKMOT’s <a class="reference internal" href="#snappy.Manifold.verify_hyperbolicity" title="snappy.Manifold.verify_hyperbolicity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verify_hyperbolicity()</span></code></a>, the result is either
<code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">listOfShapeIntervals)</span></code> or <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">[])</span></code> if verification failed.
<code class="docutils literal notranslate"><span class="pre">listOfShapesIntervals</span></code> is a list of complex intervals (elements in
sage’s <code class="docutils literal notranslate"><span class="pre">ComplexIntervalField</span></code>) certified to contain the true shapes
for the hyperbolic manifold.</p>
<p>Higher precision intervals can be obtained by setting <code class="docutils literal notranslate"><span class="pre">bits_prec</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: from snappy import Manifold
sage: M = Manifold(&quot;m019&quot;)
sage: M.verify_hyperbolicity() # doctest: +NUMERIC12
(True, [0.780552527850? + 0.914473662967?*I, 0.780552527850? + 0.91447366296773?*I, 0.4600211755737? + 0.6326241936052?*I])

sage: M = Manifold(&quot;t02333(3,4)&quot;)
sage: M.verify_hyperbolicity() # doctest: +NUMERIC9
(True, [2.152188153612? + 0.284940667895?*I, 1.92308491369? + 1.10360701507?*I, 0.014388591584? + 0.143084469681?*I, -2.5493670288? + 3.7453498408?*I, 0.142120333822? + 0.176540027036?*I, 0.504866865874? + 0.82829881681?*I, 0.50479249917? + 0.98036162786?*I, -0.589495705074? + 0.81267480427?*I])
</pre></div>
</div>
<p>One can instead get a holonomy representation associated to the
verified hyperbolic structure.  This representation takes values
in 2x2 matrices with entries in the <code class="docutils literal notranslate"><span class="pre">ComplexIntervalField</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M = Manifold(&quot;m004(1,2)&quot;)
sage: success, rho = M.verify_hyperbolicity(holonomy=True)
sage: success
True
sage: trace = rho(&#39;aaB&#39;).trace(); trace # doctest: +NUMERIC9
-0.1118628555? + 3.8536121048?*I
sage: (trace - 2).contains_zero()
False
sage: (rho(&#39;aBAbaabAB&#39;).trace() - 2).contains_zero()
True
</pre></div>
</div>
<p>Here, there is <strong>provably</strong> a fixed holonomy representation rho0
from the fundamental group G of M to SL(2, C) so that for each
element g of G the matrix rho0(g) is contained in rho(g).  In
particular, the above constitutes a proof that the word ‘aaB’ is
non-trivial in G.  In contrast, the final computation is
consistent with ‘aBAbaabAB’ being trivial in G, but <em>does not prove
this</em>.</p>
<p>A non-hyperbolic manifold (<code class="docutils literal notranslate"><span class="pre">False</span></code> indicates that the manifold
might not be hyperbolic but does <strong>not</strong> certify
non-hyperbolicity. Sometimes, hyperbolicity can only be verified
after increasing the precision):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s2">&quot;4_1(1,0)&quot;</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">verify_hyperbolicity</span><span class="p">()</span>
<span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">[])</span>
</pre></div>
</div>
<p>Under the hood, the function will call the <code class="docutils literal notranslate"><span class="pre">CertifiedShapesEngine</span></code> to produce
intervals certified to contain a solution to the rectangular gluing equations.
It then calls <code class="docutils literal notranslate"><span class="pre">check_logarithmic_gluing_equations_and_positively_oriented_tets</span></code>
to verify that the logarithmic gluing equations are fulfilled and that all
tetrahedra are positively oriented.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.volume">
<span class="sig-name descname"><span class="pre">volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">accuracy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits_prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.volume" title="Link to this definition"></a></dt>
<dd><p>Returns the volume of the current solution to the hyperbolic
gluing equations; if the solution is sufficiently non-degenerate,
this is the sum of the volumes of the hyperbolic pieces in
the geometric decomposition of the manifold.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> 
<span class="go">2.02988321</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;all tetrahedra positively oriented&#39;</span>
</pre></div>
</div>
<p>The return value has an extra attribute, accuracy, which is the
number of digits of accuracy as <em>estimated</em> by SnapPea.  When
printing the volume, the result is rounded to 1 more than this
number of digits.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vol</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">(</span><span class="n">accuracy</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">63</span><span class="p">)</span> <span class="c1"># Low precision, High precision</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Inside SageMath, verified computation of the volume of a
hyperbolic manifold is also possible (this will verify first
that the manifold is indeed hyperbolic):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sage: M.volume(verified=True, bits_prec=100)   #doctest: +NUMERIC24
2.029883212819307250042405109?
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.with_hyperbolic_structure">
<span class="sig-name descname"><span class="pre">with_hyperbolic_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.with_hyperbolic_structure" title="Link to this definition"></a></dt>
<dd><p>Add a (possibly degenerate) hyperbolic structure, turning the
<a class="reference internal" href="triangulation.html#snappy.Triangulation" title="snappy.Triangulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Triangulation</span></code></a> into a <a class="reference internal" href="#snappy.Manifold" title="snappy.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manifold</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s1">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">with_hyperbolic_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> 
<span class="go">2.02988321</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="snappy.Manifold.without_hyperbolic_structure">
<span class="sig-name descname"><span class="pre">without_hyperbolic_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.without_hyperbolic_structure" title="Link to this definition"></a></dt>
<dd><p>Returns self as a <a class="reference internal" href="triangulation.html#snappy.Triangulation" title="snappy.Triangulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Triangulation</span></code></a>, forgetting the hyperbolic
structure in the process.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s1">&#39;9_42&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">without_hyperbolic_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;volume&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="snappy.html" class="btn btn-neutral float-left" title="The snappy module and its classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="manifoldhp.html" class="btn btn-neutral float-right" title="ManifoldHP: High-precision variant" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2025, by Marc Culler, Nathan Dunfield, Matthias Goerner, Jeffrey Weeks and others.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>